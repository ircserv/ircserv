## 1. 서론

IRC 프로토콜은 테스트 기반 회의에 사용하기 위해 수년에 걸쳐 설계되었습니다. 이 문서는 현재의 IRC프로토콜에 대해서 기술합니다.

IRC 프로토콜은  TCP/IP  네트워크 프로토콜을 사용하여 개발되어왔지만, 이것이 작동하는 유일한 영역으로 남아 있어야 한다는 요구는 없습니다.

IRC 자체는 원격회의 시스템으로 클라이언트-서버 모델을 사용하여 분산된 방식으로 많은 기계에서 실행하기에 적합합니다. 일반적인 설정은 크라이언트(또는 다른 서버)가 연결할 수 있는 중심 지점을 형성하고 필요한 메시지 전달/다중화 및 기타 기능을 수행하는 단일 프로세스(서버)를 포함합니다.

### 1.1. 서버

- 서버는 IRC의 뼈대를 형성하여 클라이언트가 서로 대화할 수 있는 지점과 다른 서버가 연결할 수 있는 지점을 제공하여  IRC 네트워크를 형성합니다.
- IRC 서버에 허용되는 유일한 네트워크 구성은 각 서버가 표시되는 나머지 네트워크의 중앙 노드 역할을 하는 스패닝 트리의 구성입니다.

### 1.2. 클라이언트

- 클라이언트는 다른 서버가 아닌 모든 서버에 대한 연결입니다. 각각의 클라이언트는 최대 9글자의 닉네임을 통해 다른 클라이언트들과 구별됩니다. 닉네임으로 쓰일 수 있는 것과 쓸수 없는 것에 대해서는 프로토콜 문법 규칙을 살펴보세요.
- 닉네임에 더해, 모든 서버는 반드시 모든 클라이언트에 대한 다음의 정보들을 가지고 있어햐합니다.
  - the real name of the host that the client is running on
    (클라이언트가 실행되는 호스트의 실제 이름)
  - the username of the client on that host
    (호스트에서 클라이언트의 사용자 이름)
  - the server to which the client is connected
    (클라이언트가 연결된 서버)

### 1.2.1 오퍼레이터

-  IRC 네트워크 내에서 적절한 질서를 유지하기 위해, 특별한 종류의 클라이언트(운영자)들에게 네트워크의 일반적인 유지보수 기능을 수행할 수 있는 권한이 주어집니다. 
- 운영자에게 부여된 권한이 '위험한' 것으로 여겨질 수 있지만, 이는 필수적입니다. 
- 운영자는 잘못된 네트워크 라우팅이 장기간 사용되는 것을 방지하기 위해 필요에 따라 서버를 연결 해제하고 재연결하는 등의 기본적인 네트워크 작업을 수행할 수 있어야 합니다. 
- 이러한 필요성을 인정하여, 여기서 논의되는 프로토콜은 운영자만이 이러한 기능을 수행할 수 있도록 규정하고 있습니다. 
- 섹션 4.1.7(SQUIT)과 4.3.5(CONNECT)를 참조하십시오.

- 운영자의 더 논란이 되는 권한은 사용자를 '강제로' 연결된 네트워크에서 제거할 수 있는 능력입니다.
- 즉, 운영자는 모든 클라이언트와 서버 간의 연결을 종료할 수 있습니다. 이러한 권한의 남용은 파괴적이고 성가신 결과를 초래할 수 있기 때문에, 이에 대한 정당화는 신중해야 합니다. 
- 이러한 유형의 조치에 대한 자세한 내용은 섹션 4.6.1(KILL)을 참조하십시오.

### 1.3 채널

채널 이름은 ('&' 또는 '#' 문자로 시작하는) 최대 200자 길이의 문자열입니다. 첫 문자가 '&' 또는 '#'이어야 한다는 요구사항 외에, 채널 이름에 대한 유일한 제한은 공백(' '), 제어 문자 G(^G 또는 ASCII 7), 쉼표(',', 프로토콜에서 목록 항목 구분자로 사용됨)를 포함할 수 없다는 것입니다.

이 프로토콜에서는 두 가지 유형의 채널이 허용됩니다. 하나는 네트워크에 연결된 모든 서버에 알려진 분산 채널로, 첫 문자가 '#'인 채널입니다. 다른 하나는 해당 서버에 존재하는 클라이언트만 참여할 수 있는 로컬 채널로, '&'로 시작하는 채널입니다. 이러한 두 가지 유형 외에도, 개별 채널의 특성을 변경할 수 있는 다양한 채널 모드가 있습니다. 이에 대한 자세한 내용은 4.2.3절(MODE 명령)을 참조하십시오.

새 채널을 만들거나 기존 채널에 참여하려면, 사용자는 채널에 JOIN해야 합니다. JOIN 이전에 채널이 존재하지 않았다면, 채널이 생성되고 생성한 사용자가 채널 운영자가 됩니다. 채널이 이미 존재하는 경우, JOIN 요청이 수락되는지 여부는 해당 채널의 현재 모드에 따라 달라집니다. 예를 들어, 채널이 초대 전용(+i)인 경우 초대를 받은 경우에만 참여할 수 있습니다. 프로토콜의 일부로, 사용자는 동시에 여러 채널에 속할 수 있지만, 경험이 많은 사용자와 초보자 모두에게 10개 채널이 충분한 것으로 권장됩니다. 이에 대한 자세한 내용은 8.13절을 참조하십시오.

두 서버 간의 분할로 IRC 네트워크가 분리되면, 분할된 각 측의 채널은 해당 분할 측에 연결된 서버에 연결된 클라이언트로만 구성되며, 한쪽에서는 채널이 소멸될 수 있습니다. 분할이 복구되면, 연결되는 서버들은 각자가 생각하는 채널 멤버와 채널 모드를 서로에게 알립니다. 채널이 양쪽에 존재하는 경우, JOIN과 MODE는 포괄적인 방식으로 해석되어 새로운 연결의 양쪽이 채널의 클라이언트와 모드에 대해 동의하게 됩니다.


#### 1.3.1 채널 운영자

1.3.1 채널 운영자

주어진 채널의 채널 운영자(또는 "chop" 혹은 "chanop"이라고도 함)는 해당 채널을 '소유'하는 것으로 간주됩니다. 이러한 지위를 인정받아, 채널 운영자들은 그들의 채널에서 통제력을 유지하고 일정 수준의 질서를 유지할 수 있게 하는 특정 권한을 부여받습니다. 채널의 소유자로서, 채널 운영자는 자신의 행동에 대한 이유를 제시할 필요가 없습니다. 다만, 그들의 행동이 일반적으로 반사회적이거나 남용적인 경우, IRC 운영자에게 개입을 요청하거나, 사용자들이 떠나서 자신들만의 새로운 채널을 만드는 것이 합리적일 수 있습니다.

채널 운영자만이 사용할 수 있는 명령어는 다음과 같습니다:

    KICK    - 클라이언트를 채널에서 강제 퇴장
    MODE    - 채널의 모드 변경
    INVITE  - 초대 전용 채널(모드 +i)에 클라이언트 초대
    TOPIC   - 모드 +t 채널에서 채널 주제 변경

채널 운영자는 채널과 연관될 때마다(즉, NAMES, WHO, WHOIS 명령어에 대한 응답에서) 닉네임 옆에 '@' 기호로 식별됩니다.

## 2. IRC 명세

### 2.1 개요

여기에서 설명하는 프로토콜은 서버 간 연결과 클라이언트-서버 연결 모두에 사용됩니다. 그러나 클라이언트 연결(신뢰할 수 없는 것으로 간주됨)에는 서버 연결보다 더 많은 제한이 있습니다.

### 2.2 문자 코드

특정한 문자 집합은 지정되어 있지 않습니다. 프로토콜은 8비트로 구성된 코드 집합(옥텟)을 기반으로 합니다. 메시지는 이러한 옥텟을 여러 개 포함할 수 있습니다. 단, 일부 옥텟 값은 메시지 구분자 역할을 하는 제어 코드로 사용됩니다.

8비트 프로토콜이지만, 구분자와 키워드는 대부분 USASCII 터미널과 텔넷 연결에서 사용할 수 있도록 되어 있습니다.

IRC의 스칸디나비아 기원으로 인해, 문자 {}|는 문자 []\의 소문자 버전으로 간주됩니다. 이는 두 닉네임의 동일성을 판단할 때 중요한 사항입니다.

### 2.3 메시지

서버와 클라이언트는 서로 메시지를 주고받으며, 이 메시지는 응답을 생성할 수도 있고 아닐 수도 있습니다. 메시지가 이후 섹션에서 설명하는 유효한 명령을 포함하고 있다면, 클라이언트는 지정된 대로 응답을 예상해야 하지만 영원히 기다리는 것은 권장되지 않습니다. 클라이언트-서버 및 서버-서버 통신은 본질적으로 비동기적입니다.

각 IRC 메시지는 최대 세 부분으로 구성될 수 있습니다: 접두사(선택사항), 명령어, 명령어 매개변수(최대 15개까지 가능). 접두사, 명령어, 모든 매개변수는 하나 이상의 ASCII 공백 문자(0x20)로 구분됩니다.

접두사의 존재는 단일 선행 ASCII 콜론 문자(':', 0x3b)로 표시되며, 이는 메시지 자체의 첫 번째 문자여야 합니다. 콜론과 접두사 사이에는 간격(공백)이 없어야 합니다. 접두사는 서버가 메시지의 실제 출처를 나타내기 위해 사용합니다. 메시지에 접두사가 없는 경우, 메시지가 수신된 연결에서 시작된 것으로 간주됩니다. 클라이언트는 자신이 보내는 메시지에 접두사를 사용해서는 안 됩니다. 사용하는 경우, 유일하게 유효한 접두사는 클라이언트와 연관된 등록된 닉네임입니다. 만약 접두사로 식별된 출처가 서버의 내부 데이터베이스에서 찾을 수 없거나, 메시지가 도착한 링크와 다른 링크에서 등록된 경우, 서버는 해당 메시지를 조용히 무시해야 합니다.

명령어는 유효한 IRC 명령어이거나 ASCII 텍스트로 표현된 3자리 숫자여야 합니다.

IRC 메시지는 항상 CR-LF(Carriage Return - Line Feed) 쌍으로 끝나는 문자열이며, 이 메시지는 CR-LF를 포함하여 512자를 초과할 수 없습니다. 따라서 명령어와 매개변수에는 최대 510자가 허용됩니다. 메시지 연속 라인에 대한 규정은 없습니다. 현재 구현에 대한 자세한 내용은 7절을 참조하십시오.


#### 2.3.1 'pseudo' BNF의 메시지 형식

프로토콜 메시지는 연속된 옥텟 스트림에서 추출되어야 합니다. 현재 해결책은 CR과 LF 두 문자를 메시지 구분자로 지정하는 것입니다. 빈 메시지는 조용히 무시됩니다. 이를 통해 메시지 사이에 CR-LF 시퀀스를 추가 문제 없이 사용할 수 있습니다.

추출된 메시지는 <prefix>, <command>, 그리고 <middle> 또는 <trailing> 컴포넌트와 일치하는 매개변수 목록으로 파싱됩니다.

이에 대한 BNF 표현은 다음과 같습니다:
```bnf
<message>  ::= [':' <prefix> <SPACE> ] <command> <params> <crlf>
<prefix>   ::= <servername> | <nick> [ '!' <user> ] [ '@' <host> ]
<command>  ::= <letter> { <letter> } | <number> <number> <number>
<SPACE>    ::= ' ' { ' ' }
<params>   ::= <SPACE> [ ':' <trailing> | <middle> <params> ]

<middle>   ::= <SPACE나 NUL이나 CR이나 LF를 포함하지 않는 *비어있지 않은* 옥텟 시퀀스,
               첫 번째는 ':'가 될 수 없음>
<trailing> ::= <NUL이나 CR이나 LF를 포함하지 않는, *비어있을 수도 있는* 옥텟 시퀀스>

<crlf>     ::= CR LF
```

주의사항:

  1)    <SPACE>는 오직 SPACE 문자(들)(0x20)로만 구성됩니다.
        특히 탭과 다른 모든 제어 문자는 NON-WHITE-SPACE로 간주됩니다.

  2)    매개변수 목록을 추출한 후에는 <middle>이나 <trailing>으로 매칭되었는지 
        관계없이 모든 매개변수는 동등합니다. <trailing>은 단지 매개변수 내에서 
        SPACE를 허용하기 위한 구문적 트릭입니다.

  3)    CR과 LF가 매개변수 문자열에 나타날 수 없는 것은 단지 메시지 프레이밍의 
        결과입니다. 이는 나중에 변경될 수 있습니다.

  4)    NUL 문자는 메시지 프레이밍에서 특별하지 않으며, 기본적으로 매개변수 내에 
        들어갈 수 있지만, 일반적인 C 문자열 처리에서 추가적인 복잡성을 야기하므로 
        메시지 내에서 허용되지 않습니다.

  5)    마지막 매개변수는 빈 문자열일 수 있습니다.

  6)    확장된 접두사(['!' <user> ] ['@' <host> ])는 서버 간 통신에서 사용해서는 
        안 되며, 추가 쿼리 없이 메시지가 누구로부터 왔는지에 대한 더 유용한 정보를 
        클라이언트에게 제공하기 위해 서버에서 클라이언트로의 메시지에만 사용됩니다.

대부분의 프로토콜 메시지는 목록 내 위치에 따라 추출된 매개변수 문자열에 대한 추가적인 의미와 구문을 지정합니다. 예를 들어, 많은 서버 명령어는 명령어 이후의 첫 번째 매개변수가 대상 목록이라고 가정하며, 이는 다음과 같이 설명될 수 있습니다:

```bnf
<target>     ::= <to> [ "," <target> ]
<to>         ::= <channel> | <user> '@' <servername> | <nick> | <mask>
<channel>    ::= ('#' | '&') <chstring>
<servername> ::= <host>
<host>       ::= 허용되는 호스트명에 대한 자세한 내용은 RFC 952 [DNS:4] 참조
<nick>       ::= <letter> { <letter> | <number> | <special> }
<mask>       ::= ('#' | '$') <chstring>
<chstring>   ::= <SPACE, BELL, NUL, CR, LF 및 쉼표(',')를 제외한 모든 8비트 코드>
```

다른 매개변수 구문은 다음과 같습니다:

```bnf
<user>       ::= <nonwhite> { <nonwhite> }
<letter>     ::= 'a' ... 'z' | 'A' ... 'Z'
<number>     ::= '0' ... '9'
<special>    ::= '-' | '[' | ']' | '\' | '`' | '^' | '{' | '}'
<nonwhite>   ::= <SPACE(0x20), NUL(0x0), CR(0xd), LF(0xa)를 제외한 모든 8비트 코드>
```

### 2.4 숫자 응답

서버로 전송되는 대부분의 메시지는 어떤 형태의 응답을 생성합니다. 가장 일반적인 응답은 숫자 응답으로, 오류와 일반 응답 모두에 사용됩니다. 숫자 응답은 발신자 접두사, 세 자리 숫자, 그리고 응답의 대상으로 구성된 하나의 메시지로 전송되어야 합니다. 숫자 응답은 클라이언트로부터 시작되는 것이 허용되지 않습니다. 서버가 클라이언트로부터 이러한 메시지를 받으면 조용히 무시됩니다. 다른 모든 측면에서, 숫자 응답은 일반 메시지와 동일하지만, 키워드가 문자열 대신 3개의 숫자로 구성된다는 점이 다릅니다. 다양한 응답 목록은 6절에서 제공됩니다.

## 3. IRC 개념

이 섹션은 IRC 프로토콜 구성 뒤에 있는 실제 개념과 현재 구현이 다양한 종류의 메시지를 어떻게 전달하는지 설명하는 데 중점을 둡니다.

                          1--\
                              A        D---4
                          2--/ \      /
                                B----C
                               /      \
                              3        E

   서버: A, B, C, D, E         클라이언트: 1, 2, 3, 4

                    [ 그림 2. 작은 IRC 네트워크 샘플 ]

### 3.1 일대일 통신

일대일 통신은 주로 클라이언트들 사이에서 이루어지며, 대부분의 서버-서버 트래픽은 서버들이 서로 직접 대화하는 결과가 아닙니다. 클라이언트들이 서로 안전하게 대화할 수 있도록 하기 위해, 모든 서버는 스패닝 트리를 따라 정확히 한 방향으로 메시지를 전송하여 모든 클라이언트에게 도달할 수 있어야 합니다. 메시지가 전달되는 경로는 스패닝 트리 상의 두 지점 사이의 최단 경로입니다.

다음 예시들은 모두 위의 그림 2를 참조합니다.

예시 1:
     클라이언트 1과 2 사이의 메시지는 서버 A에서만 보이며, 
     서버 A는 이를 직접 클라이언트 2에게 전송합니다.

예시 2:
     클라이언트 1과 3 사이의 메시지는 서버 A와 B, 그리고 클라이언트 3에게만 
     보입니다. 다른 클라이언트나 서버는 이 메시지를 볼 수 없습니다.

예시 3:
     클라이언트 2와 4 사이의 메시지는 서버 A, B, C, D와 클라이언트 4에게만 
     보입니다.

### 3.2 일대다

IRC의 주요 목적은 쉽고 효율적인 회의(일대다 대화)를 위한 포럼을 제공하는 것입니다. IRC는 이를 달성하기 위한 여러 수단을 제공하며, 각각은 고유한 목적을 가지고 있습니다.

#### 3.2.1 목록으로

일대다 대화의 가장 비효율적인 방식은 클라이언트가 '목록'의 사용자들과 대화하는 것입니다. 이는 거의 자명합니다: 클라이언트가 메시지를 전달할 대상 목록을 제공하면 서버가 이를 분할하고 지정된 각 대상에 별도의 메시지 사본을 전송합니다. 이는 그룹을 사용하는 것만큼 효율적이지 않은데, 목록이 분할되고 각 경로로 중복 전송이 되는지 확인하지 않고 전송되기 때문입니다.

#### 3.2.2 그룹으로 (채널)

IRC에서 채널은 멀티캐스트 그룹과 동등한 역할을 합니다. 채널의 존재는 동적이며(사람들이 채널에 참여하고 떠나면서 생성되고 사라짐), 채널에서 이루어지는 실제 대화는 해당 채널에 있는 사용자를 지원하는 서버에만 전송됩니다. 동일한 채널에 여러 사용자가 있는 서버의 경우, 메시지 텍스트는 해당 서버에 한 번만 전송된 다음 채널에 있는 각 클라이언트에게 전송됩니다. 이 작업은 원래 메시지가 퍼져나가 채널의 각 구성원에게 도달할 때까지 각 클라이언트-서버 조합에 대해 반복됩니다.

다음 예시들은 모두 그림 2를 참조합니다.

예시 4:
     1명의 클라이언트가 있는 모든 채널. 채널로 전송되는 메시지는 
     서버로 전송된 후 더 이상 어디로도 전달되지 않습니다.

예시 5:
     2명의 클라이언트가 있는 채널. 모든 메시지는 채널 외부에서 두 클라이언트 간에 
     개인 메시지를 주고받는 것과 같은 경로로 전달됩니다.

예시 6:
     채널에 클라이언트 1, 2, 3이 있는 경우. 채널로 전송되는 모든 메시지는 
     모든 클라이언트에게 전송되며, 단일 클라이언트에 대한 개인 메시지였다면 
     거쳐야 했을 서버들만 통과합니다. 클라이언트 1이 메시지를 보내면, 
     클라이언트 2에게 돌아가고 서버 B를 통해 클라이언트 3에게 전달됩니다.

#### 3.2.3 호스트/서버 마스크로

IRC 운영자들에게 관련된 대규모 사용자 그룹에 메시지를 보낼 수 있는 메커니즘을 제공하기 위해, 호스트 및 서버 마스크 메시지가 제공됩니다. 이 메시지들은 호스트나 서버 정보가 마스크와 일치하는 사용자들에게 전송됩니다. 메시지는 채널과 유사한 방식으로 사용자가 있는 위치에만 전송됩니다.

### 3.3 일대전체

일대전체 유형의 메시지는 모든 클라이언트나 서버 또는 둘 다에게 전송되는 브로드캐스트 메시지로 더 잘 설명됩니다. 사용자와 서버가 많은 대규모 네트워크에서는 단일 메시지가 의도한 모든 목적지에 도달하기 위해 네트워크를 통해 많은 트래픽이 전송될 수 있습니다.

일부 메시지의 경우, 각 서버가 가지고 있는 상태 정보가 서버들 간에 합리적으로 일관되게 유지되도록 하기 위해 모든 서버에 브로드캐스트하는 것 외에는 다른 선택이 없습니다.

#### 3.3.1 클라이언트-클라이언트

단일 메시지로 다른 모든 클라이언트에게 메시지가 전송되는 메시지 클래스는 없습니다.

#### 3.3.2 클라이언트-서버

채널 멤버십, 채널 모드, 사용자 상태 등의 상태 정보 변경을 초래하는 대부분의 명령어는 기본적으로 모든 서버에 전송되어야 하며, 이 배포는 클라이언트가 변경할 수 없습니다.

#### 3.3.3 서버-서버

서버 간의 대부분의 메시지가 모든 '다른' 서버에 배포되지만, 이는 사용자, 채널 또는 서버에 영향을 미치는 메시지에 대해서만 필요합니다. 이것들이 IRC에서 발견되는 기본 항목이므로, 서버에서 시작되는 거의 모든 메시지는 다른 모든 연결된 서버에 브로드캐스트됩니다.

## 4. 메시지 세부사항

다음 페이지들에는 IRC 서버와 클라이언트가 인식하는 각 메시지에 대한 설명이 있습니다. 이 섹션에서 설명하는 모든 명령어는 여기서 설명하는 프로토콜의 작동하는 서버 구현에서 반드시 구현되어야 합니다.

ERR_NOSUCHSERVER 응답이 나열된 경우, 이는 <server> 매개변수를 찾을 수 없음을 의미합니다. 서버는 이 이후에 해당 명령어에 대해 다른 응답을 보내서는 안 됩니다.

클라이언트가 연결된 서버는 완전한 메시지를 파싱하고 적절한 오류를 반환해야 합니다. 서버가 메시지를 파싱하는 동안 치명적인 오류가 발생하면, 오류를 클라이언트에게 보내고 파싱을 종료해야 합니다. 치명적인 오류는 잘못된 명령어, 서버에 알려지지 않은 목적지(서버, 닉네임 또는 채널 이름이 이 범주에 속함), 매개변수 부족 또는 잘못된 권한 등이 될 수 있습니다.

전체 매개변수 집합이 제시되면, 각각의 유효성을 검사하고 적절한 응답을 클라이언트에게 보내야 합니다. 쉼표를 항목 구분자로 사용하는 매개변수 목록을 사용하는 메시지의 경우, 각 항목에 대해 응답을 보내야 합니다.

아래 예시에서 일부 메시지는 전체 형식을 사용하여 나타납니다:

   :Name COMMAND parameter list

이러한 예시는 "Name"에서 시작되어 서버 간을 이동 중인 메시지를 나타내며, 여기서 원래 메시지 발신자의 이름을 포함하는 것이 필수적입니다. 이는 원격 서버가 올바른 경로를 따라 응답을 보낼 수 있도록 하기 위함입니다.

### 4.1 연결 등록

여기서 설명하는 명령어들은 사용자나 서버로서 IRC 서버와의 연결을 등록하고 올바르게 연결을 해제하는 데 사용됩니다.

클라이언트나 서버 연결이 등록되기 위해 "PASS" 명령어가 필수는 아니지만, 서버 메시지나 NICK/USER 조합 중 후자보다 먼저 와야 합니다. 연결에 어느 정도의 보안을 제공하기 위해 모든 서버 연결에 비밀번호를 사용하는 것이 강력히 권장됩니다. 클라이언트가 등록하는 데 권장되는 순서는 다음과 같습니다:

           1. Pass 메시지
           2. Nick 메시지
           3. User 메시지

#### 4.1.1 Password 메시지

  명령어: PASS
  매개변수: <password>

  PASS 명령어는 '연결 비밀번호'를 설정하는 데 사용됩니다. 비밀번호는 연결 등록을 시도하기 전에 설정할 수 있고 반드시 설정해야 합니다. 현재 이것은 클라이언트가 NICK/USER 조합을 보내기 전에 PASS 명령어를 보내야 하고, 서버는 반드시 모든 SERVER 명령어 전에 PASS 명령어를 보내야 함을 의미합니다. 제공된 비밀번호는 C/N 라인(서버의 경우) 또는 I 라인(클라이언트의 경우)에 포함된 것과 일치해야 합니다. 등록하기 전에 여러 PASS 명령어를 보내는 것이 가능하지만 마지막으로 보낸 것만 확인에 사용되며, 한 번 등록되면 변경할 수 없습니다.

   숫자 응답:
           ERR_NEEDMOREPARAMS              ERR_ALREADYREGISTRED

   예시:
           PASS secretpasswordhere

#### 4.1.2 Nick 메시지

      명령어: NICK
   매개변수: <nickname> [ <hopcount> ]

   NICK 메시지는 사용자에게 닉네임을 부여하거나 이전 닉네임을 변경하는 데 사용됩니다. <hopcount> 매개변수는 닉네임이 홈 서버에서 얼마나 멀리 떨어져 있는지 표시하기 위해 서버에서만 사용됩니다. 로컬 연결은 hopcount가 0입니다. 클라이언트가 제공한 경우 무시되어야 합니다.

   다른 클라이언트에 대해 동일한 닉네임을 이미 알고 있는 서버에 NICK 메시지가 도착하면, 닉네임 충돌이 발생합니다. 닉네임 충돌의 결과로, 해당 닉네임의 모든 인스턴스가 서버의 데이터베이스에서 제거되고, KILL 명령어가 발행되어 다른 모든 서버의 데이터베이스에서 해당 닉네임을 제거합니다. 충돌을 일으킨 NICK 메시지가 닉네임 변경이었다면, 원래(이전) 닉네임도 제거되어야 합니다.

   서버가 직접 연결된 클라이언트로부터 동일한 NICK을 받으면, 로컬 클라이언트에게 ERR_NICKCOLLISION을 발행하고, NICK 명령어를 무시하며, KILL을 생성하지 않을 수 있습니다.

   숫자 응답:
           ERR_NONICKNAMEGIVEN             ERR_ERRONEUSNICKNAME
           ERR_NICKNAMEINUSE               ERR_NICKCOLLISION

   예시:
   NICK Wiz                        ; 새로운 닉네임 "Wiz" 소개.

   :WiZ NICK Kilroy                ; WiZ가 자신의 닉네임을 Kilroy로 변경.

#### 4.1.3 User 메시지

      명령어: USER
   매개변수: <username> <hostname> <servername> <realname>

   USER 메시지는 연결 시작 시 새로운 사용자의 사용자명, 호스트명, 서버명, 실명을 지정하는 데 사용됩니다. 또한 서버 간 통신에서 IRC에 새로 도착한 사용자를 표시하는 데도 사용되는데, USER와 NICK이 모두 클라이언트로부터 수신된 후에만 사용자가 등록되기 때문입니다.

   서버 간에는 USER 메시지 앞에 반드시 클라이언트의 닉네임이 접두사로 붙어야 합니다. 호스트명과 서버명은 USER 명령어가 직접 연결된 클라이언트로부터 올 때 보안상의 이유로 IRC 서버에서 일반적으로 무시되지만, 서버 간 통신에서는 사용됩니다. 이는 새로운 사용자가 나머지 네트워크에 소개될 때 동반되는 USER가 전송되기 전에 항상 NICK이 원격 서버로 전송되어야 함을 의미합니다.

   realname 매개변수는 반드시 마지막 매개변수여야 하며, 공백 문자를 포함할 수 있기 때문에 콜론(':')을 접두사로 붙여 이것이 인식되도록 해야 합니다.

   USER 메시지만으로 사용자명을 확인하는 것이 쉽기 때문에, "Identity Server" 사용이 권장됩니다. 사용자가 연결하는 호스트에 이러한 서버가 활성화되어 있으면 사용자명은 "Identity Server"의 응답에 따라 설정됩니다.

   숫자 응답:
           ERR_NEEDMOREPARAMS              ERR_ALREADYREGISTRED

   예시:

   USER guest tolmoon tolsun :Ronnie Reagan
                                   ; "guest"라는 사용자명과 "Ronnie Reagan"이라는 
                                   실명으로 사용자 등록.

   :testnick USER guest tolmoon tolsun :Ronnie Reagan
                                   ; USER 명령어가 속한 닉네임과 함께 
                                   서버 간에 전송되는 메시지

#### 4.1.4 Server 메시지

      명령어: SERVER
   매개변수: <servername> <hopcount> <info>

   server 메시지는 새로운 연결의 다른 쪽 끝이 서버임을 서버에 알리는 데 사용됩니다. 이 메시지는 또한 전체 네트워크에 서버 데이터를 전달하는 데 사용됩니다. 새로운 서버가 네트워크에 연결되면, 그에 대한 정보가 전체 네트워크에 브로드캐스트됩니다. <hopcount>는 모든 서버에 얼마나 멀리 떨어져 있는지에 대한 내부 정보를 제공하는 데 사용됩니다. 전체 서버 목록이 있으면 전체 서버 트리의 지도를 구성할 수 있지만, 호스트마스크가 이를 방지합니다.

   SERVER 메시지는 (a) 아직 등록되지 않았고 서버로 등록하려고 시도하는 연결이나 (b) 다른 서버에 대한 기존 연결에서만 받아들여져야 하며, 이 경우 SERVER 메시지는 해당 서버 뒤에 있는 새로운 서버를 소개합니다.

   SERVER 명령어 수신과 관련된 대부분의 오류는 대상 호스트(대상 SERVER)가 연결을 종료하는 결과를 초래합니다. 오류 응답은 일반적으로 숫자 대신 "ERROR" 명령어를 사용하여 전송되는데, ERROR 명령어가 여기에서 유용한 여러 속성을 가지고 있기 때문입니다.

   SERVER 메시지가 파싱되어 수신 서버에 이미 알려진 서버를 소개하려고 하면, 해당 메시지가 온 연결은 (올바른 절차에 따라) 닫혀야 합니다. 서버에 대한 중복 경로가 형성되어 IRC 트리의 비순환 특성이 깨졌기 때문입니다.

   숫자 응답:
           ERR_ALREADYREGISTRED

   예시:

SERVER test.oulu.fi 1 :[tolsun.oulu.fi] Experimental server
                                ; 새로운 서버 test.oulu.fi가 자신을 소개하고
                                등록을 시도함. []안의 이름은 test.oulu.fi를
                                실행하는 호스트의 호스트명임.

:tolsun.oulu.fi SERVER csd.bu.edu 5 :BU Central Server
                                ; 서버 tolsun.oulu.fi는 5홉 떨어진 
                                csd.bu.edu에 대한 우리의 업링크임.
#### 4.1.5 Oper

      명령어: OPER
   매개변수: <user> <password>

   OPER 메시지는 일반 사용자가 운영자 권한을 얻기 위해 사용됩니다. <user>와 <password>의 조합이 운영자 상태를 얻기 위해 필요합니다.

   OPER 명령어를 보내는 클라이언트가 주어진 사용자에 대해 올바른 비밀번호를 제공하면, 서버는 클라이언트의 닉네임에 대해 "MODE +o"를 발행하여 네트워크의 나머지 부분에 새로운 운영자를 알립니다.

   OPER 메시지는 클라이언트-서버 간에만 사용됩니다.

   숫자 응답:
           ERR_NEEDMOREPARAMS              RPL_YOUREOPER
           ERR_NOOPERHOST                  ERR_PASSWDMISMATCH

   예시:
   OPER foo bar                    ; "foo"를 사용자명으로, "bar"를 비밀번호로 
                                   사용하여 운영자로 등록을 시도.

#### 4.1.6 Quit

      명령어: QUIT
   매개변수: [<Quit message>]

   클라이언트 세션은 quit 메시지로 종료됩니다. 서버는 QUIT 메시지를 보내는 클라이언트와의 연결을 반드시 종료해야 합니다. "Quit Message"가 제공되면 기본 메시지인 닉네임 대신 이 메시지가 전송됩니다.

   네트스플릿(두 서버의 연결 해제)이 발생할 때, quit 메시지는 공백으로 구분된 두 관련 서버의 이름으로 구성됩니다. 첫 번째 이름은 여전히 연결된 서버의 이름이고 두 번째 이름은 연결이 끊긴 서버의 이름입니다.

   다른 이유로 클라이언트가 QUIT 명령어를 보내지 않고 클라이언트 연결이 종료되는 경우(예: 클라이언트가 죽고 소켓에서 EOF가 발생), 서버는 연결 종료를 야기한 이벤트의 성격을 반영하는 일종의 메시지로 quit 메시지를 채워야 합니다.

   숫자 응답:
           없음

   예시:
   QUIT :Gone to have lunch        ; 선호되는 메시지 형식.
  

#### 4.1.7 Server quit 메시지

      명령어: SQUIT
   매개변수: <server> <comment>

   SQUIT 메시지는 종료하거나 죽은 서버에 대해 알리는 데 필요합니다. 서버가 다른 서버와의 연결을 끊고자 할 경우, 서버 매개변수로 다른 서버의 이름을 사용하여 SQUIT 메시지를 다른 서버에 보내야 하며, 그러면 해당 서버는 종료하는 서버와의 연결을 닫습니다.

   이 명령어는 IRC 네트워크의 연결을 질서 있게 유지하는 데 도움이 되도록 운영자들도 사용할 수 있습니다. 운영자는 원격 서버 연결에 대해서도 SQUIT 메시지를 발행할 수 있습니다. 이 경우, SQUIT는 운영자와 원격 서버 사이의 각 서버에서 파싱되어야 하며, 아래 설명된 대로 각 서버가 보유한 네트워크 뷰를 업데이트해야 합니다.

   <comment>는 원격 서버(현재 있는 서버에 직접 연결되지 않은)에 대해 SQUIT를 실행하는 모든 운영자가 제공해야 합니다. 이는 다른 운영자들이 이 조치의 이유를 알 수 있게 하기 위함입니다. <comment>는 또한 서버에 의해 채워질 수 있으며, 오류나 유사한 메시지를 여기에 넣을 수 있습니다.

   연결이 닫히는 양쪽의 서버는 모두 해당 링크 뒤에 있는 것으로 간주되는 모든 다른 서버에 대해 SQUIT 메시지를(다른 모든 서버 연결에) 보내야 합니다.

   마찬가지로, 해당 링크 뒤에 있는 모든 클라이언트를 대신하여 네트워크의 다른 연결된 서버에 QUIT 메시지를 보내야 합니다. 또한 분할로 인해 멤버를 잃은 채널의 모든 채널 멤버에게 QUIT 메시지를 보내야 합니다.

   서버 연결이 조기에 종료되는 경우(예: 링크의 다른 쪽 끝에 있는 서버가 죽은 경우), 이 연결 해제를 감지한 서버는 네트워크의 나머지 부분에 연결이 닫혔음을 알리고 적절한 내용으로 comment 필드를 채워야 합니다.

   숫자 응답:
           ERR_NOPRIVILEGES                ERR_NOSUCHSERVER

   예시:

   SQUIT tolsun.oulu.fi :Bad Link ? ; 서버 링크 tolsun.oulu.fi가 
                                   "Bad Link" 때문에 종료됨.

   :Trillian SQUIT cm22.eng.umd.edu :Server out of control
                                    ; "Server out of control" 때문에
                                    "cm22.eng.umd.edu"를 네트워크에서 
                                    연결 해제하라는 Trillian의 메시지.

### 4.2 채널 작업

이 메시지 그룹은 채널, 채널의 속성(채널 모드) 및 채널의 내용(일반적으로 클라이언트)을 조작하는 것과 관련이 있습니다. 이를 구현할 때, 네트워크의 반대쪽 끝에 있는 클라이언트가 결국 충돌할 명령어를 보낼 때 여러 경쟁 조건이 불가피합니다. 또한 서버가 최근에 변경된 경우를 대비하여 닉네임 기록을 유지해야 합니다. <nick> 매개변수가 제공될 때마다 서버가 그 기록을 확인할 수 있도록 하기 위함입니다.

#### 4.2.1 Join 메시지

      명령어: JOIN
   매개변수: <channel>{,<channel>} [<key>{,<key>}]

   JOIN 명령어는 클라이언트가 특정 채널의 청취를 시작하는 데 사용됩니다. 클라이언트가 채널에 참여할 수 있는지 여부는 클라이언트가 연결된 서버에서만 확인됩니다. 다른 모든 서버는 다른 서버로부터 받았을 때 자동으로 사용자를 채널에 추가합니다. 이에 영향을 미치는 조건은 다음과 같습니다:

           1.  채널이 invite-only인 경우 사용자는 초대를 받아야 합니다;
           2.  사용자의 nick/username/hostname이 활성화된 차단과 일치하지 않아야 합니다;
           3.  설정된 경우 올바른 키(비밀번호)가 제공되어야 합니다.

이에 대한 자세한 내용은 MODE 명령어에서 설명합니다(자세한 내용은 4.2.3절 참조).

사용자가 채널에 참여하면, 서버가 해당 채널에 영향을 미치는 받은 모든 명령어에 대한 알림을 받습니다. 여기에는 MODE, KICK, PART, QUIT 그리고 물론 PRIVMSG/NOTICE가 포함됩니다. JOIN 명령어는 모든 서버에 브로드캐스트되어야 하므로 각 서버가 채널에 있는 사용자를 어디서 찾을 수 있는지 알 수 있습니다. 이를 통해 채널에 대한 PRIVMSG/NOTICE의 최적화된 전달이 가능합니다.

JOIN이 성공하면, 사용자는 채널의 주제(RPL_TOPIC 사용)와 채널에 있는 사용자 목록(RPL_NAMREPLY 사용)을 받게 되며, 여기에는 참여하는 사용자도 포함되어야 합니다.

   숫자 응답:
           ERR_NEEDMOREPARAMS              ERR_BANNEDFROMCHAN
           ERR_INVITEONLYCHAN              ERR_BADCHANNELKEY
           ERR_CHANNELISFULL               ERR_BADCHANMASK
           ERR_NOSUCHCHANNEL               ERR_TOOMANYCHANNELS
           RPL_TOPIC

   예시:

   JOIN #foobar                    ; #foobar 채널에 참여.

   JOIN &foo fubar                 ; 키 "fubar"를 사용하여 &foo 채널에 참여.

   JOIN #foo,&bar fubar            ; 키 "fubar"를 사용하여 #foo 채널에 참여하고
                                   키 없이 &bar에 참여.

   JOIN #foo,#bar fubar,foobar     ; 키 "fubar"를 사용하여 #foo 채널에 참여하고
                                   키 "foobar"를 사용하여 #bar 채널에 참여.

   JOIN #foo,#bar                  ; 채널 #foo와 #bar에 참여.

   :WiZ JOIN #Twilight_zone        ; WiZ로부터의 JOIN 메시지

##### 4.2.2 Part 메시지

**명령**: PART
**매개변수**: <채널>{,<채널>}

PART 메시지는 메시지를 보내는 클라이언트를 매개변수 문자열에 나열된 모든 주어진 채널의 활성 사용자 목록에서 제거하는 원인이 됩니다.

**수치 응답**:

- ERR_NEEDMOREPARAMS
- ERR_NOSUCHCHANNEL
- ERR_NOTONCHANNEL

**예시**:

```
PART #twilight_zone             ; "#twilight_zone" 채널 나가기

PART #oz-ops,&group5            ; "&group5"와 "#oz-ops" 두 채널 모두 나가기
```

#### 4.2.3 Mode 메시지

**명령**: MODE

IRC에서 MODE 명령은 이중 용도 명령입니다. 사용자 이름과 채널 모두 모드를 변경할 수 있습니다. 이러한 선택의 근거는 언젠가 닉네임이 더 이상 사용되지 않을 것이고 그에 상응하는 속성이 채널이 될 것이라는 점입니다.

MODE 메시지를 파싱할 때, 먼저 전체 메시지를 파싱한 다음 그 결과로 발생한 변경사항을 전달하는 것이 권장됩니다.

###### 4.2.3.1 채널 모드

**매개변수**: <채널> {[+|-]|o|p|s|i|t|n|b|v} [<제한>] [<사용자>] [<차단 마스크>]

MODE 명령은 채널 운영자가 '자신의' 채널의 특성을 변경할 수 있도록 제공됩니다. 또한 서버가 채널 모드를 변경할 수 있어야 채널 운영자를 생성할 수 있습니다.

채널에 사용 가능한 다양한 모드는 다음과 같습니다:

- o - 채널 운영자 권한 부여/제거
- p - 비공개 채널 플래그
- s - 비밀 채널 플래그
- i - 초대 전용 채널 플래그
- t - 토픽은 채널 운영자만 설정 가능한 플래그
- n - 외부 클라이언트로부터 채널로의 메시지 금지
- m - 중재된 채널
- l - 채널의 사용자 제한 설정
- b - 사용자를 차단하기 위한 차단 마스크 설정
- v - 중재된 채널에서 발언 권한 부여/제거
- k - 채널 키(비밀번호) 설정

'o'와 'b' 옵션을 사용할 때, 모드 명령당 총 3개의 제한이 부과되었습니다.

###### 4.2.3.2 사용자 모드

**매개변수**: <닉네임> {[+|-]|i|w|s|o}

사용자 MODE는 일반적으로 클라이언트가 다른 사람들에게 어떻게 보이는지 또는 클라이언트가 어떤 '추가' 메시지를 받는지에 영향을 미치는 변경사항입니다. 사용자 MODE 명령은 메시지 발신자와 매개변수로 주어진 닉네임이 모두 동일한 경우에만 수락될 수 있습니다.

사용 가능한 모드는 다음과 같습니다:

- i - 사용자를 보이지 않음으로 표시
- s - 서버 알림을 받도록 사용자 표시
- w - 사용자가 wallops를 수신
- o - 운영자 플래그

추가 모드는 나중에 사용 가능할 수 있습니다.

사용자가 "+o" 플래그를 사용하여 자신을 운영자로 만들려고 시도하면, 그 시도는 무시되어야 합니다. 하지만 누구나 "-o"를 사용하여 자신의 운영자 권한을 해제하는 것에는 제한이 없습니다.

**수치 응답**:

- ERR_NEEDMOREPARAMS
- RPL_CHANNELMODEIS
- ERR_CHANOPRIVSNEEDED
- ERR_NOSUCHNICK
- ERR_NOTONCHANNEL
- ERR_KEYSET
- RPL_BANLIST
- RPL_ENDOFBANLIST
- ERR_UNKNOWNMODE
- ERR_NOSUCHCHANNEL
- ERR_USERSDONTMATCH
- RPL_UMODEIS
- ERR_UMODEUNKNOWNFLAG

**예시**:

채널 모드 사용:
```
MODE #Finnish +im               ; #Finnish 채널을 중재 모드와 '초대 전용'으로 만듦.

MODE #Finnish +o Kilroy         ; Kilroy에게 #Finnish 채널에서 '채널운영자' 권한을 줌.

MODE #Finnish +v Wiz            ; WiZ가 #Finnish에서 발언할 수 있도록 허용.

MODE #Fins -s                   ; #Fins 채널에서 '비밀' 플래그 제거.

MODE #42 +k oulu                ; 채널 키를 "oulu"로 설정.

MODE #eu-opers +l 10            ; 채널의 사용자 수 제한을 10으로 설정.

MODE &oulu +b                   ; 채널에 설정된 차단 마스크 목록.

MODE &oulu +b *!*@*             ; 모든 사용자의 참가를 방지.

MODE &oulu +b *!*@*.edu         ; *.edu와 일치하는 호스트네임을 가진 모든 사용자의 참가를 방지.
```

사용자 모드 사용:
```
:MODE WiZ -w                    ; WiZ의 WALLOPS 메시지 수신을 끔.

:Angel MODE Angel +i            ; Angel이 자신을 보이지 않게 만드는 메시지.

MODE WiZ -o                     ; WiZ가 '운영자 해제'(운영자 상태 제거).
                                이 명령의 단순한 반대("MODE WiZ +o")는
                                OPER 명령을 우회할 수 있으므로
                                사용자로부터 허용되어서는 안 됨.
```

#### 4.2.4 Topic 메시지

**명령**: TOPIC
**매개변수**: <채널> [<토픽>]

TOPIC 메시지는 채널의 토픽을 변경하거나 보는 데 사용됩니다. <토픽>이 주어지지 않은 경우 <채널>의 토픽이 반환됩니다. <토픽> 매개변수가 있는 경우, 채널 모드가 이 작업을 허용한다면 해당 채널의 토픽이 변경됩니다.

**수치 응답**:

- ERR_NEEDMOREPARAMS
- ERR_NOTONCHANNEL
- RPL_NOTOPIC
- RPL_TOPIC
- ERR_CHANOPRIVSNEEDED

**예시**:

```
:Wiz TOPIC #test :New topic     ;사용자 Wiz가 토픽을 설정함.

TOPIC #test :another topic      ;#test의 토픽을 "another topic"으로 설정.

TOPIC #test                     ; #test의 토픽 확인.
```

#### 4.2.5 Names 메시지

**명령**: NAMES
**매개변수**: [<채널>{,<채널>}]

NAMES 명령을 사용하여 클라이언트는 볼 수 있는 모든 채널에서 볼 수 있는 모든 닉네임 목록을 생성하는 쿼리를 생성할 수 있습니다. 볼 수 있는 채널은 비공개(+p)나 비밀(+s)이 아니거나 실제로 참여하고 있는 채널입니다. <채널> 매개변수는 유효한 경우 정보를 반환할 채널을 지정합니다. 잘못된 채널 이름에 대한 오류 응답은 없습니다.

<채널> 매개변수가 주어지지 않으면 모든 채널과 그 구성원의 목록이 반환됩니다. 이 목록 끝에는 어떤 채널에도 없거나 보이는 채널에 없는 사용자들의 목록이 '*' '채널'에 있는 것으로 나열됩니다.

**수치 응답**:

- RPL_NAMREPLY
- RPL_ENDOFNAMES

**예시**:

```
NAMES #twilight_zone,#42        ; 채널이 보이는 경우 #twilight_zone과
                                #42의 보이는 사용자 목록.

NAMES                           ; 모든 보이는 채널과 사용자 목록
```

#### 4.2.6 List 메시지

**명령**: LIST
**매개변수**: [<채널>{,<채널>} [<서버>]]

list 메시지는 채널과 그 토픽을 나열하는 데 사용됩니다. <채널> 매개변수가 사용되면 해당 채널의 상태만 표시됩니다. 비공개 채널은 쿼리를 생성하는 클라이언트가 실제로 해당 채널에 있지 않는 한 토픽 없이 "Prv" 채널로 나열됩니다. 마찬가지로 비밀 채널은 클라이언트가 해당 채널의 구성원이 아닌 한 전혀 나열되지 않습니다.

**수치 응답**:

- ERR_NOSUCHSERVER
- RPL_LISTSTART
- RPL_LIST
- RPL_LISTEND

**예시**:

```
LIST                            ; 모든 채널 나열.

LIST #twilight_zone,#42         ; 채널 #twilight_zone과 #42 나열
```

#### 4.2.7 Invite 메시지

**명령**: INVITE
**매개변수**: <닉네임> <채널>

INVITE 메시지는 사용자를 채널에 초대하는 데 사용됩니다. 매개변수 <닉네임>은 대상 채널 <채널>에 초대될 사람의 닉네임입니다. 대상 사용자가 초대되는 채널이 존재하거나 유효한 채널이어야 한다는 요구 사항은 없습니다. 초대 전용인 채널(MODE +i)에 사용자를 초대하려면, 초대를 보내는 클라이언트가 해당 채널의 채널 운영자로 인정되어야 합니다.

**수치 응답**:

- ERR_NEEDMOREPARAMS
- ERR_NOSUCHNICK
- ERR_NOTONCHANNEL
- ERR_USERONCHANNEL
- ERR_CHANOPRIVSNEEDED
- RPL_INVITING
- RPL_AWAY

**예시**:

```
:Angel INVITE Wiz #Dust         ; 사용자 Angel이 WiZ를 채널
                                #Dust에 초대

INVITE Wiz #Twilight_Zone       ; WiZ를 #Twilight_zone에 
                                초대하는 명령
```

#### 4.2.8 Kick 명령

**명령**: KICK
**매개변수**: <채널> <사용자> [<코멘트>]

KICK 명령은 사용자를 채널에서 강제로 제거하는 데 사용될 수 있습니다. 채널에서 '강제 퇴장'시킵니다(강제 PART). 채널 운영자만이 다른 사용자를 채널에서 강제 퇴장시킬 수 있습니다. KICK 메시지를 받는 각 서버는 강제 퇴장 대상을 채널에서 제거하기 전에 그것이 유효한지(즉, 발신자가 실제로 채널 운영자인지) 확인합니다.

**수치 응답**:

- ERR_NEEDMOREPARAMS
- ERR_NOSUCHCHANNEL
- ERR_BADCHANMASK
- ERR_CHANOPRIVSNEEDED
- ERR_NOTONCHANNEL

**예시**:

```
KICK &Melbourne Matthew         ; Matthew를 &Melbourne에서 강제 퇴장

KICK #Finnish John :Speaking English
                                ; John을 #Finnish에서 "Speaking English"를
                                이유(코멘트)로 강제 퇴장.

:WiZ KICK #Finnish John         ; WiZ가 John을 채널 #Finnish에서 
                                제거하는 KICK 메시지
```

**참고**:
KICK 명령 매개변수를 다음과 같이 확장하는 것이 가능합니다:

```
<채널>{,<채널>} <사용자>{,<사용자>} [<코멘트>]
```

### 4.3 서버 쿼리와 명령

서버 쿼리 그룹의 명령들은 네트워크에 연결된 모든 서버에 대한 정보를 반환하도록 설계되었습니다. 연결된 모든 서버는 이러한 쿼리에 응답해야 하며 정확하게 응답해야 합니다. 유효하지 않은 응답(또는 응답 부재)은 서버의 오류 징후로 간주되어야 하며, 상황이 해결될 때까지 가능한 한 빨리 연결을 끊거나 비활성화해야 합니다.

이러한 쿼리에서 매개변수가 "<서버>"로 나타나는 경우, 일반적으로 닉네임이나 서버 또는 일종의 와일드카드 이름이 될 수 있음을 의미합니다. 그러나 각 매개변수에 대해 하나의 쿼리와 응답 세트만 생성되어야 합니다.

#### 4.3.1 Version 메시지

**명령**: VERSION
**매개변수**: [<서버>]

VERSION 메시지는 서버 프로그램의 버전을 쿼리하는 데 사용됩니다. 선택적 매개변수 <서버>는 클라이언트가 직접 연결되지 않은 서버의 버전을 쿼리하는 데 사용됩니다.

**수치 응답**:

- ERR_NOSUCHSERVER
- RPL_VERSION

**예시**:

```
:Wiz VERSION *.se               ; Wiz가 "*.se"와 일치하는 서버의 버전을 확인하는 메시지

VERSION tolsun.oulu.fi          ; "tolsun.oulu.fi" 서버의 버전 확인
```

#### 4.3.2 Stats 메시지

**명령**: STATS
**매개변수**: [<쿼리> [<서버>]]

stats 메시지는 특정 서버의 통계를 쿼리하는 데 사용됩니다. <서버> 매개변수가 생략되면 stats 응답의 끝만 다시 전송됩니다. 이 명령의 구현은 응답하는 서버에 따라 매우 다르지만, 서버는 아래에 설명된 쿼리(또는 유사한)에 의해 설명된 정보를 제공할 수 있어야 합니다.

쿼리는 목적지 서버(만약 <서버> 매개변수로 주어진 경우)에 의해서만 확인되는 단일 문자로 주어질 수 있으며, 그 외에는 중간 서버에 의해 전달되고, 무시되며 변경되지 않습니다. 다음 쿼리들은 현재 IRC 구현에서 발견되는 것들이며 해당 서버에 대한 설정 정보의 상당 부분을 제공합니다. 이러한 것들이 다른 버전에서 동일한 방식으로 지원되지 않을 수 있지만, 모든 서버는 현재 사용되는 응답 형식과 일관되고 쿼리의 목적에 맞는 STATS 쿼리에 대한 유효한 응답을 제공할 수 있어야 합니다.

현재 지원되는 쿼리는 다음과 같습니다:

- c - 서버가 연결할 수 있거나 연결을 허용할 수 있는 서버 목록 반환
- h - leaf로 취급되거나 hub로 동작하도록 허용된 서버 목록 반환
- i - 서버가 클라이언트의 연결을 허용하는 호스트 목록 반환
- k - 해당 서버에 대한 금지된 사용자이름/호스트이름 조합 목록 반환
- l - 서버의 연결 목록 반환, 각 연결이 얼마나 오래 유지되었는지와 각 방향의 바이트 및 메시지 단위의 트래픽 표시
- m - 서버가 지원하는 명령 목록과 사용 횟수가 0이 아닌 경우 각각의 사용 횟수 반환
- o - 일반 클라이언트가 운영자가 될 수 있는 호스트 목록 반환
- y - 서버의 설정 파일에서 Y(Class) 라인 표시
- u - 서버가 얼마나 오래 실행되었는지 보여주는 문자열 반환

**수치 응답**:

- ERR_NOSUCHSERVER
- RPL_STATSCLINE
- RPL_STATSNLINE
- RPL_STATSILINE
- RPL_STATSKLINE
- RPL_STATSQLINE
- RPL_STATSLLINE
- RPL_STATSLINKINFO
- RPL_STATSUPTIME
- RPL_STATSCOMMANDS
- RPL_STATSOLINE
- RPL_STATSHLINE
- RPL_ENDOFSTATS

**예시**:

```
STATS m                         ; 연결된 서버의 명령 사용량 확인

:Wiz STATS c eff.org            ; Wiz가 eff.org 서버의 C/N 라인
                                정보를 요청
```

#### 4.3.3 Links 메시지

**명령**: LINKS
**매개변수**: [[<원격 서버>] <서버 마스크>]

LINKS를 사용하면 사용자는 쿼리에 응답하는 서버가 알고 있는 모든 서버를 나열할 수 있습니다. 반환된 서버 목록은 마스크와 일치해야 하며, 마스크가 주어지지 않은 경우 전체 목록이 반환됩니다.

<원격 서버>가 <서버 마스크>와 함께 주어진 경우, LINKS 명령은 해당 이름과 일치하는 첫 번째 서버(있는 경우)로 전달되며, 해당 서버는 쿼리에 응답해야 합니다.

**수치 응답**:

- ERR_NOSUCHSERVER
- RPL_LINKS
- RPL_ENDOFLINKS

**예시**:

```
LINKS *.au                      ; *.au와 일치하는 이름을 가진 모든 서버 나열

:WiZ LINKS *.bu.edu *.edu       ; *.edu와 일치하는 첫 번째 서버에 대한
                                WiZ의 LINKS 메시지로 *.bu.edu와 일치하는
                                서버 목록 요청
```

#### 4.3.4 Time 메시지

**명령**: TIME
**매개변수**: [<서버>]

time 메시지는 지정된 서버의 로컬 시간을 쿼리하는 데 사용됩니다. 서버 매개변수가 주어지지 않으면 명령을 처리하는 서버가 쿼리에 응답해야 합니다.

**수치 응답**:

- ERR_NOSUCHSERVER
- RPL_TIME

**예시**:

```
TIME tolsun.oulu.fi             ; "tolson.oulu.fi" 서버의 시간 확인

Angel TIME *.au                 ; 사용자 angel이 "*.au"와 일치하는 서버의
                                시간 확인
```

#### 4.3.5 Connect 메시지

**명령**: CONNECT
**매개변수**: <대상 서버> [<포트> [<원격 서버>]]

CONNECT 명령은 서버가 즉시 다른 서버와 새로운 연결을 시도하도록 강제하는 데 사용될 수 있습니다. CONNECT는 특권 명령이며 IRC 운영자만 사용할 수 있어야 합니다. 원격 서버가 주어진 경우 CONNECT 시도는 해당 서버에 의해 <대상 서버>와 <포트>로 이루어집니다.

**수치 응답**:

- ERR_NOSUCHSERVER
- ERR_NOPRIVILEGES
- ERR_NEEDMOREPARAMS

**예시**:

```
CONNECT tolsun.oulu.fi          ; 서버를 tolsun.oulu.fi에 연결 시도

:WiZ CONNECT eff.org 6667 csd.bu.edu
                                ; WiZ가 eff.org와 csd.bu.edu 서버를
                                포트 6667로 연결하도록 시도
```

#### 4.3.6 Trace 메시지

**명령**: TRACE
**매개변수**: [<서버>]

TRACE 명령은 특정 서버로의 경로를 찾는 데 사용됩니다. 이 메시지를 처리하는 각 서버는 "traceroute" 사용 시 얻을 수 있는 것과 유사한 응답 체인을 형성하는 경유 링크임을 나타내는 응답을 발신자에게 보내야 합니다. 이 응답을 다시 보낸 후, 주어진 서버에 도달할 때까지 다음 서버로 TRACE 메시지를 보내야 합니다. <서버> 매개변수가 생략된 경우, TRACE 명령은 현재 서버가 직접 연결되어 있는 서버들에 대한 메시지를 발신자에게 보내는 것이 권장됩니다.

"<서버>"로 주어진 목적지가 실제 서버인 경우, 목적지 서버는 연결된 모든 서버와 사용자를 보고해야 하지만, 운영자만이 현재 사용자를 볼 수 있습니다. 만약 <서버>로 주어진 목적지가 닉네임인 경우, 해당 닉네임에 대한 응답만 주어집니다.

**수치 응답**:

- ERR_NOSUCHSERVER

TRACE 메시지가 다른 서버로 향하는 경우, 모든 중간 서버는 TRACE가 통과했음을 나타내고 다음 목적지를 표시하기 위해 RPL_TRACELINK 응답을 반환해야 합니다.

- RPL_TRACELINK

TRACE 응답은 다음과 같은 수치 응답 중 임의의 수로 구성될 수 있습니다.

- RPL_TRACECONNECTING
- RPL_TRACEHANDSHAKE
- RPL_TRACEUNKNOWN
- RPL_TRACEOPERATOR
- RPL_TRACEUSER
- RPL_TRACESERVER
- RPL_TRACESERVICE
- RPL_TRACENEWTYPE
- RPL_TRACECLASS

**예시**:

```
TRACE *.oulu.fi                 ; *.oulu.fi와 일치하는 서버로 TRACE

:WiZ TRACE AngelDust            ; WiZ가 닉네임 AngelDust에 대해 발행한 TRACE
```

#### 4.3.7 Admin 명령

**명령**: ADMIN
**매개변수**: [<서버>]

admin 메시지는 주어진 서버의 관리자 이름을 찾는 데 사용되며, <서버> 매개변수가 생략된 경우 현재 서버의 관리자 이름을 찾습니다. 각 서버는 ADMIN 메시지를 다른 서버로 전달할 수 있어야 합니다.

**수치 응답**:

- ERR_NOSUCHSERVER
- RPL_ADMINME
- RPL_ADMINLOC1
- RPL_ADMINLOC2
- RPL_ADMINEMAIL

**예시**:

```
ADMIN tolsun.oulu.fi            ; tolsun.oulu.fi로부터 ADMIN 응답 요청

:WiZ ADMIN *.edu                ; *.edu와 일치하는 첫 번째 서버에 대한
                                WiZ의 ADMIN 요청
```

#### 4.3.8 Info 명령

**명령**: INFO
**매개변수**: [<서버>]

INFO 명령은 서버를 설명하는 정보를 반환해야 합니다: 버전, 컴파일된 시기, 패치레벨, 시작된 시기, 그리고 관련이 있다고 여겨질 수 있는 기타 기타 정보들.

**수치 응답**:

- ERR_NOSUCHSERVER
- RPL_INFO
- RPL_ENDOFINFO

**예시**:

```
INFO csd.bu.edu                 ; csd.bu.edu로부터 INFO 응답 요청

:Avalon INFO *.fi               ; *.fi와 일치하는 첫 번째 서버에 대한
                                Avalon의 INFO 요청

INFO Angel                      ; Angel이 연결된 서버에 대한 정보 요청
```

### 4.4 메시지 전송

IRC 프로토콜의 주요 목적은 클라이언트들이 서로 통신할 수 있는 기반을 제공하는 것입니다. PRIVMSG와 NOTICE는 한 클라이언트에서 다른 클라이언트로 텍스트 메시지를 실제로 전달하는 데 사용할 수 있는 유일한 메시지입니다 - 나머지는 단지 그것을 가능하게 만들고 신뢰할 수 있고 구조화된 방식으로 이루어지도록 보장하려고 시도합니다.

#### 4.4.1 Private 메시지

**명령**: PRIVMSG
**매개변수**: <수신자>{,<수신자>} <전송할 텍스트>

PRIVMSG는 사용자 간의 비공개 메시지를 보내는 데 사용됩니다. <수신자>는 메시지를 받는 사람의 닉네임입니다. <수신자>는 쉼표로 구분된 이름이나 채널 목록일 수도 있습니다.

<수신자> 매개변수는 호스트 마스크(#mask) 또는 서버 마스크($mask)일 수도 있습니다. 두 경우 모두 서버는 서버나 호스트가 마스크와 일치하는 사람들에게만 PRIVMSG를 보냅니다. 마스크는 마지막 "." 다음에 와일드카드가 없고 최소 1(하나)의 "."가 있어야 합니다. 이 요구사항은 사람들이 "#*" 또는 "$*"로 메시지를 보내는 것을 방지하기 위해 존재하며, 이는 모든 사용자에게 브로드캐스트될 것입니다. 경험상 이는 책임감 있고 적절하게 사용되는 것보다 남용되는 경우가 더 많습니다. 와일드카드는 '*'와 '?' 문자입니다. PRIVMSG 명령의 이 확장은 운영자만 사용할 수 있습니다.

**수치 응답**:

- ERR_NORECIPIENT
- ERR_NOTEXTTOSEND
- ERR_CANNOTSENDTOCHAN
- ERR_NOTOPLEVEL
- ERR_WILDTOPLEVEL
- ERR_TOOMANYTARGETS
- ERR_NOSUCHNICK
- RPL_AWAY

**예시**:

```
:Angel PRIVMSG Wiz :Hello are you receiving this message ?
                                ; Angel에서 Wiz로의 메시지.

PRIVMSG Angel :yes I'm receiving it !receiving it !'u>(768u+1n) .br ;
                                Angel에게 보내는 메시지.

PRIVMSG jto@tolsun.oulu.fi :Hello !
                                ; tolsun.oulu.fi 서버의 "jto" 사용자
                                이름을 가진 클라이언트에게 보내는 메시지.

PRIVMSG $*.fi :Server tolsun.oulu.fi rebooting.
                                ; *.fi와 일치하는 이름을 가진 서버의
                                모든 사람에게 보내는 메시지.

PRIVMSG #*.edu :NSFNet is undergoing work, expect interruptions
                                ; *.edu와 일치하는 호스트에서 온 모든
                                사용자에게 보내는 메시지.
```

#### 4.4.2 Notice

**명령**: NOTICE
**매개변수**: <닉네임> <텍스트>

NOTICE 메시지는 PRIVMSG와 유사하게 사용됩니다. NOTICE와 PRIVMSG의 차이점은 NOTICE 메시지에 대한 자동 응답이 절대 보내지면 안 된다는 것입니다. 이 규칙은 서버에도 적용됩니다 - 서버는 NOTICE를 받았을 때 클라이언트에게 어떤 오류 응답도 보내서는 안 됩니다. 이 규칙의 목적은 무언가를 받은 것에 대해 자동으로 응답하는 클라이언트가 다른 자동화 프로그램과 루프에 빠지는 것을 피하는 것입니다. 이는 일반적으로 자동화 프로그램(AI나 다른 대화형 프로그램이 그들의 행동을 제어하는 클라이언트)에 의해 사용되며, 다른 자동화 프로그램과 루프에 빠지지 않도록 항상 응답을 보내는 것으로 보입니다.

응답과 예시에 대해서는 PRIVMSG를 참조하십시오.

### 4.5 사용자 기반 쿼리

사용자 쿼리는 특정 사용자나 사용자 그룹에 대한 세부 정보를 찾는 것과 주로 관련된 명령 그룹입니다. 이러한 명령들과 함께 와일드카드를 사용할 때, 일치하는 경우 당신에게 '보이는' 사용자에 대한 정보만 반환합니다. 사용자의 가시성은 사용자의 모드와 당신이 모두 속해 있는 공통 채널의 조합으로 결정됩니다.

#### 4.5.1 Who 쿼리

**명령**: WHO
**매개변수**: [<이름> [<o>]]

WHO 메시지는 클라이언트가 클라이언트가 제공한 <이름> 매개변수와 '일치하는' 정보 목록을 반환하는 쿼리를 생성하는 데 사용됩니다. <이름> 매개변수가 없는 경우, 모든 보이는 사용자(보이지 않는 사용자가 아닌(사용자 모드 +i) 그리고 요청하는 클라이언트와 공통 채널이 없는)가 나열됩니다. "0" 또는 가능한 모든 항목과 일치하는 와일드카드를 <이름>으로 사용하여 동일한 결과를 얻을 수 있습니다.

WHO에 전달된 <이름>은 채널 <이름>을 찾을 수 없는 경우 사용자의 호스트, 서버, 실제 이름 및 닉네임과 대조됩니다.

"o" 매개변수가 전달되면 제공된 이름 마스크에 따라 운영자만 반환됩니다.

**수치 응답**:

- ERR_NOSUCHSERVER
- RPL_WHOREPLY
- RPL_ENDOFWHO

**예시**:

```
WHO *.fi                        ; "*.fi"와 일치하는 모든 사용자 나열.

WHO jto* o                      ; 만약 그들이 운영자인 경우 "jto*"와
                                일치하는 모든 사용자 나열.
```

#### 4.5.2 Whois 쿼리

**명령**: WHOIS
**매개변수**: [<서버>] <닉마스크>[,<닉마스크>[,...]]

이 메시지는 특정 사용자에 대한 정보를 쿼리하는 데 사용됩니다. 서버는 닉마스크와 일치하는 각 사용자의 다양한 상태를 나타내는 여러 수치 메시지로 이 메시지에 응답합니다(귀하가 볼 수 있는 권한이 있는 경우). <닉마스크>에 와일드카드가 없는 경우, 해당 닉네임에 대해 귀하가 볼 수 있는 모든 정보가 표시됩니다. 쉼표(',')로 구분된 닉네임 목록이 제공될 수 있습니다.

후자 버전은 쿼리를 특정 서버로 보냅니다. 이는 해당 사용자가 얼마나 오래 유휴 상태였는지 알고 싶을 때 유용합니다. 로컬 서버(즉, 사용자가 직접 연결된 서버)만이 그 정보를 알고 있는 반면, 다른 모든 것은 전역적으로 알려져 있기 때문입니다.

**수치 응답**:

- ERR_NOSUCHSERVER
- ERR_NONICKNAMEGIVEN
- RPL_WHOISUSER
- RPL_WHOISCHANNELS
- RPL_WHOISCHANNELS
- RPL_WHOISSERVER
- RPL_AWAY
- RPL_WHOISOPERATOR
- RPL_WHOISIDLE
- ERR_NOSUCHNICK
- RPL_ENDOFWHOIS

**예시**:

```
WHOIS wiz                       ; WiZ에 대한 사용 가능한 사용자 정보 반환

WHOIS eff.org trillian          ; eff.org 서버에 trillian에 대한 사용자
                                정보 요청
```

#### 4.5.3 Whowas

**명령**: WHOWAS
**매개변수**: <닉네임> [<카운트> [<서버>]]

Whowas는 더 이상 존재하지 않는 닉네임에 대한 정보를 요청합니다. 이는 닉네임 변경이나 사용자가 IRC를 떠난 경우일 수 있습니다. 이 쿼리에 대한 응답으로, 서버는 어휘적으로 동일한 닉네임을 찾기 위해 닉네임 기록을 검색합니다(여기서는 와일드카드 매칭 없음). 기록은 뒤로 검색되어 가장 최근 항목을 먼저 반환합니다. 여러 항목이 있는 경우, <카운트> 응답까지 반환됩니다(<카운트> 매개변수가 주어지지 않은 경우 모든 항목). 양수가 아닌 수가 <카운트>로 전달되면 전체 검색이 수행됩니다.

**수치 응답**:

- ERR_NONICKNAMEGIVEN
- ERR_WASNOSUCHNICK
- RPL_WHOWASUSER
- RPL_WHOISSERVER
- RPL_ENDOFWHOWAS

**예시**:

```
WHOWAS Wiz                      ; 닉네임 "WiZ"에 대한 닉네임 기록의
                                모든 정보 반환

WHOWAS Mermaid 9                ; "Mermaid"에 대한 닉네임 기록에서
                                최근 9개 항목 반환

WHOWAS Trillian 1 *.edu         ; "*.edu"와 일치하는 첫 번째 서버에서
                                "Trillian"에 대한 가장 최근 기록 반환
```

### 4.6 기타 메시지

이 카테고리의 메시지들은 위의 카테고리들 중 어느 것에도 맞지 않지만, 그럼에도 불구하고 여전히 프로토콜의 일부이며 필요한 것들입니다.

#### 4.6.1 Kill 메시지

**명령**: KILL
**매개변수**: <닉네임> <코멘트>

KILL 메시지는 실제 연결을 가진 서버가 클라이언트-서버 연결을 닫도록 하는 데 사용됩니다. KILL은 서버가 유효한 닉네임 목록에서 중복 항목을 발견했을 때 사용되며, 두 항목을 모두 제거하는 데 사용됩니다. 이는 운영자도 사용할 수 있습니다.

자동 재연결 알고리즘을 가진 클라이언트는 연결 해제가 일시적이기 때문에 이 명령을 사실상 무용하게 만듭니다. 하지만 데이터 흐름을 중단시키고 대량의 남용을 중지하는 데 사용할 수 있습니다. 모든 사용자는 다른 사람들을 위해 생성된 KILL 메시지를 수신하여 잠재적인 문제 지점을 '감시'하도록 선택할 수 있습니다.

닉네임이 항상 전역적으로 고유해야 하는 환경에서, KILL 메시지는 '중복'이 감지될 때마다 전송됩니다(즉, 같은 닉네임으로 두 사용자를 등록하려는 시도)는 두 사용자 모두 사라지고 1명만 다시 나타나기를 바라면서 전송됩니다.

주어진 코멘트는 KILL의 실제 이유를 반영해야 합니다. 서버가 생성한 KILL의 경우 일반적으로 충돌하는 두 닉네임의 출처에 대한 세부 정보로 구성됩니다. 사용자의 경우 그것을 보는 다른 사람들을 만족시킬 수 있는 적절한 이유를 제공하는 것은 그들에게 달려 있습니다. KILLER의 신원을 숨기기 위한 가짜 KILL 생성을 방지/저지하기 위해, 코멘트는 또한 각 서버를 통과할 때마다 업데이트되는 'kill-경로'를 보여주며, 각 서버는 자신의 이름을 경로 앞에 추가합니다.

**수치 응답**:

- ERR_NOPRIVILEGES
- ERR_NEEDMOREPARAMS
- ERR_NOSUCHNICK
- ERR_CANTKILLSERVER

```
KILL David (csd.bu.edu <- tolsun.oulu.fi)
                                   ; csd.bu.edu와 tolson.oulu.fi 사이의
                                   닉네임 충돌
```

**참고**:
KILL 메시지로 다른 사용자를 죽일 수 있는 권한은 운영자에게만 주어지는 것이 권장됩니다. 이상적인 세상에서는 운영자조차도 이것을 할 필요가 없을 것이며 서버가 처리하도록 남겨둘 것입니다.

#### 4.6.2 Ping 메시지

**명령**: PING
**매개변수**: <서버1> [<서버2>]

PING 메시지는 연결의 다른 쪽 끝에 있는 활성 클라이언트의 존재를 테스트하는 데 사용됩니다. 연결에서 다른 활동이 감지되지 않으면 정기적으로 PING 메시지가 전송됩니다. 연결이 설정된 시간 내에 PING 명령에 응답하지 않으면 해당 연결이 종료됩니다.

PING 메시지를 받는 모든 클라이언트는 <서버1>(PING 메시지를 보낸 서버)에 가능한 한 빨리 적절한 PONG 메시지로 응답하여 여전히 존재하고 활성 상태임을 나타내야 합니다. 서버는 PING 명령에 응답해서는 안 되며 연결의 다른 쪽 끝에서 오는 PING을 통해 연결이 활성 상태임을 나타내야 합니다. <서버2> 매개변수가 지정된 경우, PING 메시지는 거기로 전달됩니다.

**수치 응답**:

- ERR_NOORIGIN
- ERR_NOSUCHSERVER

**예시**:

```
PING tolsun.oulu.fi             ; 서버가 여전히 활성 상태임을 나타내기 위해
                                다른 서버에 PING 메시지를 보냄

PING WiZ                        ; WiZ 닉네임으로 보내지는 PING 메시지
```

#### 4.6.3 Pong 메시지

**명령**: PONG
**매개변수**: <데몬> [<데몬2>]

PONG 메시지는 ping 메시지에 대한 응답입니다. 매개변수 <데몬2>가 주어진 경우 이 메시지는 주어진 데몬으로 전달되어야 합니다. <데몬> 매개변수는 PING 메시지에 응답하고 이 메시지를 생성한 데몬의 이름입니다.

**수치 응답**:

- ERR_NOORIGIN
- ERR_NOSUCHSERVER

**예시**:

```
PONG csd.bu.edu tolsun.oulu.fi  ; csd.bu.edu에서 tolsun.oulu.fi로의
                                PONG 메시지
```

#### 4.6.4 Error

**명령**: ERROR
**매개변수**: <에러 메시지>

ERROR 명령은 서버가 운영자들에게 심각하거나 치명적인 오류를 보고할 때 사용됩니다. 이는 한 서버에서 다른 서버로 보낼 수도 있지만 일반적인 알 수 없는 클라이언트로부터는 받아들여서는 안 됩니다.

ERROR 메시지는 서버 간 링크에서 발생하는 오류를 보고하는 데만 사용됩니다. ERROR 메시지는 다른 쪽 끝의 서버(이는 연결된 모든 운영자에게 전송)와 현재 연결된 모든 운영자에게 보내집니다. 서버가 서버로부터 ERROR 메시지를 받은 경우 다른 서버로 전달해서는 안 됩니다.

서버가 받은 ERROR 메시지를 운영자에게 보낼 때, 메시지는 NOTICE 메시지 안에 캡슐화되어야 하며, 클라이언트가 오류의 원인이 아니었음을 나타내야 합니다.

**수치 응답**:

없음.

**예시**:

```
ERROR :Server *.fi already exists; 이 오류를 일으킨 다른 서버에 대한
                                ERROR 메시지.

NOTICE WiZ :ERROR from csd.bu.edu -- Server *.fi already exists
                                ; 위와 동일한 ERROR 메시지이지만 다른
                                서버의 사용자 WiZ에게 보내짐.
```

## 5. 선택사항

이 섹션은 선택적 메시지들을 설명합니다. 이들은 여기에 설명된 프로토콜의 작동하는 서버 구현에 필수적이지 않습니다. 옵션이 없는 경우, 오류 응답 메시지를 생성하거나 알 수 없는 명령 오류를 생성해야 합니다. 메시지가 다른 서버가 응답하도록 되어 있는 경우 전달되어야 합니다(기본적인 파싱 필요). 이에 대해 할당된 수치는 아래 메시지와 함께 나열되어 있습니다.

### 5.1 Away

**명령**: AWAY
**매개변수**: [메시지]

AWAY 메시지를 사용하면 클라이언트는 자신에게 보내지는 PRIVMSG 명령(자신이 속한 채널이 아닌)에 대한 자동 응답 문자열을 설정할 수 있습니다. 자동 응답은 서버가 PRIVMSG 명령을 보내는 클라이언트에게 보냅니다. 응답하는 서버는 보내는 클라이언트가 연결된 서버뿐입니다.

AWAY 메시지는 하나의 매개변수(AWAY 메시지 설정)를 사용하거나 매개변수 없이(AWAY 메시지 제거) 사용됩니다.

**수치 응답**:

- RPL_UNAWAY
- RPL_NOWAWAY

**예시**:

```
AWAY :Gone to lunch.  Back in 5 ; AWAY 메시지를 "Gone to lunch.
                                Back in 5"로 설정.

:WiZ AWAY                       ; WiZ를 자리 비움 상태에서 해제.
```

### 5.2 Rehash 메시지

**명령**: REHASH
**매개변수**: 없음

rehash 메시지는 운영자가 서버에게 설정 파일을 다시 읽고 처리하도록 강제할 때 사용할 수 있습니다.

**수치 응답**:

- RPL_REHASHING
- ERR_NOPRIVILEGES

**예시**:

```
REHASH                          ; 운영자 상태를 가진 클라이언트가 서버에게
                                설정 파일을 다시 읽도록 요청하는 메시지.
```

### 5.3 Restart 메시지

**명령**: RESTART
**매개변수**: 없음

restart 메시지는 운영자만이 서버를 강제로 재시작하게 하는데 사용할 수 있습니다. 이 메시지는 선택사항입니다. 임의의 사람이 운영자로서 서버에 연결하여 이 명령을 실행하면 (최소한) 서비스 중단을 일으킬 수 있기 때문에 위험으로 볼 수 있기 때문입니다.

RESTART 명령은 보내는 클라이언트가 연결된 서버에 의해 항상 완전히 처리되어야 하며 다른 연결된 서버로 전달되어서는 안 됩니다.

**수치 응답**:

- ERR_NOPRIVILEGES

**예시**:

```
RESTART                         ; 매개변수 필요 없음.
```

### 5.4 Summon 메시지

**명령**: SUMMON
**매개변수**: <사용자> [<서버>]

SUMMON 명령은 IRC 서버를 실행하는 호스트에 있는 사용자에게 IRC에 참여해달라는 메시지를 보내는 데 사용할 수 있습니다. 이 메시지는 대상 서버가 (a) SUMMON이 활성화되어 있고, (b) 사용자가 로그인되어 있으며 (c) 서버 프로세스가 사용자의 tty(또는 유사한)에 쓸 수 있는 경우에만 전송됩니다.

<서버> 매개변수가 주어지지 않으면 클라이언트가 연결된 서버에서 <사용자>를 소환하려고 시도합니다.

서버에서 summon이 활성화되어 있지 않은 경우, ERR_SUMMONDISABLED 수치를 반환하고 summon 메시지를 계속 전달해야 합니다.

**수치 응답**:

- ERR_NORECIPIENT
- ERR_FILEERROR
- ERR_NOLOGIN
- ERR_NOSUCHSERVER
- RPL_SUMMONING

**예시**:

```
SUMMON jto                      ; 서버의 호스트에서 사용자 jto 소환

SUMMON jto tolsun.oulu.fi       ; "tolsun.oulu.fi"라는 이름의 서버가 
                                실행 중인 호스트에서 사용자 jto 소환
```

### 5.5 Users

**명령**: USERS
**매개변수**: [<서버>]

USERS 명령은 who(1), rusers(1), finger(1)와 유사한 형식으로 서버에 로그인된 사용자 목록을 반환합니다. 일부 사람들은 보안 관련 이유로 이 명령을 서버에서 비활성화할 수 있습니다. 비활성화된 경우, 이를 나타내기 위해 올바른 수치가 반환되어야 합니다.

**수치 응답**:

- ERR_NOSUCHSERVER
- ERR_FILEERROR
- RPL_USERSSTART
- RPL_USERS
- RPL_NOUSERS
- RPL_ENDOFUSERS
- ERR_USERSDISABLED

**비활성화 응답**:

- ERR_USERSDISABLED

**예시**:

```
USERS eff.org                   ; eff.org 서버에 로그인된 사용자 목록 요청

:John USERS tolsun.oulu.fi      ; John이 tolsun.oulu.fi 서버에 로그인된
                                사용자 목록을 요청
```

### 5.6 Operwall 메시지

**명령**: WALLOPS
**매개변수**: 현재 온라인인 모든 운영자에게 보낼 텍스트

현재 온라인인 모든 운영자에게 메시지를 보냅니다. WALLOPS를 사용자 명령으로 구현한 후, 많은 사람들에게 메시지를 보내는 수단으로(WALL과 매우 유사하게) 자주 그리고 일반적으로 남용되는 것이 발견되었습니다. 이로 인해 현재 WALLOPS 구현을 예시로 사용하여 서버만을 WALLOPS의 발신자로 인식하고 허용하는 것이 권장됩니다.

**수치 응답**:

- ERR_NEEDMOREPARAMS

**예시**:

```
:csd.bu.edu WALLOPS :Connect '*.uiuc.edu 6667' from Joshua; Joshua로부터
                                   받은 CONNECT 메시지를 발표하는
                                   csd.bu.edu의 WALLOPS 메시지.
```

### 5.7 Userhost 메시지

**명령**: USERHOST
**매개변수**: <닉네임>{<공백><닉네임>}

USERHOST 명령은 최대 5개의 닉네임 목록을 받아 각 닉네임을 공백 문자로 구분하여 찾은 각 닉네임에 대한 정보 목록을 반환합니다. 반환된 목록은 각 응답이 공백으로 구분되어 있습니다.

**수치 응답**:

- RPL_USERHOST
- ERR_NEEDMOREPARAMS

**예시**:

```
USERHOST Wiz Michael Marty p    ;닉네임 "Wiz", "Michael", "Marty", "p"에
                                대한 USERHOST 정보 요청
```

### 5.8 Ison 메시지

**명령**: ISON
**매개변수**: <닉네임>{<공백><닉네임>}

ISON 명령은 주어진 닉네임이 현재 IRC에 있는지에 대한 빠르고 효율적인 응답을 얻기 위해 구현되었습니다. ISON은 하나(1)의 매개변수만 사용합니다: 공백으로 구분된 닉네임 목록. 목록의 각 닉네임이 존재하는 경우, 서버는 그것을 응답 문자열에 추가합니다. 따라서 응답 문자열은 비어 있거나(어느 것도 존재하지 않음), 매개변수 문자열의 정확한 복사본(모두 존재함), 또는 주어진 닉네임 집합의 다른 하위 집합일 수 있습니다. 확인할 수 있는 닉네임 수의 유일한 제한은 서버가 512자에 맞도록 잘라내야 할 정도로 결합된 길이가 너무 길지 않아야 한다는 것입니다.

ISON은 명령을 보내는 클라이언트에 로컬인 서버에서만 처리되며, 따라서 추가 처리를 위해 다른 서버로 전달되지 않습니다.

**수치 응답**:

- RPL_ISON
- ERR_NEEDMOREPARAMS

**예시**:

```
ISON phone trillian WiZ jarlek Avalon Angel Monstah
                                   ; 7개의 닉네임에 대한 ISON 요청 예시.
```

## 6. 응답

다음은 위에서 주어진 명령에 대한 응답으로 생성되는 수치 응답 목록입니다. 각 수치는 번호, 이름 및 응답 문자열과 함께 제공됩니다.

### 6.1 오류 응답

```
401     ERR_NOSUCHNICK
                "<nickname> :No such nick/channel"

                - 명령에 제공된 닉네임 매개변수가 현재 사용되지 않음을
                  나타내는 데 사용됩니다.

402     ERR_NOSUCHSERVER
                "<server name> :No such server"

                - 주어진 서버 이름이 현재 존재하지 않음을 나타내는 데
                  사용됩니다.

403     ERR_NOSUCHCHANNEL
                "<channel name> :No such channel"

                - 주어진 채널 이름이 유효하지 않음을 나타내는 데
                  사용됩니다.

404     ERR_CANNOTSENDTOCHAN
                "<channel name> :Cannot send to channel"

                - (a) 모드 +n인 채널에 있지 않거나 (b) 모드 +m이 설정된
                  채널에서 채널운영자(또는 모드 +v)가 아닌 상태에서
                  해당 채널에 PRIVMSG 메시지를 보내려고 시도하는
                  사용자에게 전송됩니다.

405     ERR_TOOMANYCHANNELS
                "<channel name> :You have joined too many \
                 channels"
                - 사용자가 허용된 최대 채널 수에 도달했을 때 다른
                  채널에 참여하려고 시도할 때 전송됩니다.

406     ERR_WASNOSUCHNICK  
                "<nickname> :There was no such nickname"

                - WHOWAS에서 해당 닉네임에 대한 기록 정보가 없음을
                  나타내기 위해 반환됩니다.

407     ERR_TOOMANYTARGETS
                "<target> :Duplicate recipients. No message \
                 delivered"

                - user@host 대상 형식을 사용하여 PRIVMSG/NOTICE를
                  보내려고 시도하는 클라이언트에 반환되며,
                  여러 번 발생하는 user@host에 대한 것입니다.

409     ERR_NOORIGIN
                ":No origin specified"

                - 이러한 명령은 유효한 접두사 없이도 작동해야 하므로
                  PING 또는 PONG 메시지에 필수적인 발신자 매개변수가
                  누락되었습니다.

411     ERR_NORECIPIENT
                ":No recipient given (<command>)"
412     ERR_NOTEXTTOSEND
                ":No text to send"
413     ERR_NOTOPLEVEL
                "<mask> :No toplevel domain specified"
414     ERR_WILDTOPLEVEL
                "<mask> :Wildcard in toplevel domain"

                - 412 - 414는 어떤 이유로 메시지가 전달되지 않았음을
                  나타내기 위해 PRIVMSG에 의해 반환됩니다.
                  ERR_NOTOPLEVEL과 ERR_WILDTOPLEVEL은
                  "PRIVMSG $<server>" 또는 "PRIVMSG #<host>"의
                  잘못된 사용이 시도될 때 반환되는 오류입니다.

421     ERR_UNKNOWNCOMMAND
                "<command> :Unknown command"

                - 서버가 알지 못하는 명령을 보낸 등록된 클라이언트에게
                  반환됩니다.

422     ERR_NOMOTD
                ":MOTD File is missing"

                - 서버의 MOTD 파일을 서버가 열 수 없었습니다.

423     ERR_NOADMININFO
                "<server> :No administrative info available"

                - 적절한 정보를 찾는 데 오류가 있을 때 ADMIN 메시지에
                  대한 응답으로 서버가 반환합니다.

424     ERR_FILEERROR
                ":File error doing <file op> on <file>"

                - 메시지 처리 중 파일 작업이 실패했을 때 사용되는
                  일반적인 오류 메시지입니다.

431     ERR_NONICKNAMEGIVEN
                ":No nickname given"

                - 명령에 필요한 닉네임 매개변수가 발견되지 않았을 때
                  반환됩니다.

432     ERR_ERRONEUSNICKNAME
                "<nick> :Erroneus nickname"

                - 정의된 집합에 속하지 않는 문자를 포함하는 NICK
                  메시지를 받은 후 반환됩니다. 유효한 닉네임에 대한
                  자세한 내용은 섹션 x.x.x를 참조하십시오.
                  
433     ERR_NICKNAMEINUSE
                "<nick> :Nickname is already in use"

                - 현재 존재하는 닉네임으로 변경하려는 시도로 인해
                  처리되는 NICK 메시지가 반환될 때 반환됩니다.

436     ERR_NICKCOLLISION
                "<nick> :Nickname collision KILL"

                - 서버가 닉네임 충돌을 감지했을 때(다른 서버에 의해
                  이미 존재하는 NICK의 등록) 클라이언트에게 서버가
                  반환합니다.

441     ERR_USERNOTINCHANNEL
                "<nick> <channel> :They aren't on that channel"

                - 명령의 대상 사용자가 주어진 채널에 없음을 나타내기
                  위해 서버가 반환합니다.

442     ERR_NOTONCHANNEL
                "<channel> :You're not on that channel"

                - 클라이언트가 멤버가 아닌 채널에 영향을 미치는 명령을
                  수행하려고 할 때마다 서버가 반환합니다.

443     ERR_USERONCHANNEL
                "<user> <channel> :is already on channel"

                - 클라이언트가 이미 채널에 있는 사용자를 초대하려고
                  할 때 반환됩니다.

444     ERR_NOLOGIN
                "<user> :User not logged in"

                - SUMMON 명령 후 사용자가 로그인하지 않아 수행할 수
                  없을 때 반환됩니다.

445     ERR_SUMMONDISABLED
                ":SUMMON has been disabled"

                - SUMMON 명령에 대한 응답으로 반환됩니다. 이를 구현하지
                  않는 모든 서버가 반환해야 합니다.

446     ERR_USERSDISABLED
                ":USERS has been disabled"

                - USERS 명령에 대한 응답으로 반환됩니다. 이를 구현하지
                  않는 모든 서버가 반환해야 합니다.

451     ERR_NOTREGISTERED
                ":You have not registered"

                - 서버가 클라이언트를 자세히 파싱하도록 허용하기 전에
                  클라이언트가 등록되어야 함을 나타내기 위해
                  반환됩니다.

461     ERR_NEEDMOREPARAMS
                "<command> :Not enough parameters"

                - 클라이언트가 충분한 매개변수를 제공하지 않았음을
                  나타내기 위해 수많은 명령에 의해 서버가 반환합니다.

462     ERR_ALREADYREGISTRED
                ":You may not reregister"

                - 등록된 세부 정보의 일부(예: 두 번째 USER 메시지의
                  비밀번호나 사용자 세부 정보)를 변경하려는 모든
                  링크에 서버가 반환합니다.

463     ERR_NOPERMFORHOST
                ":Your host isn't among the privileged"

                - 시도된 연결이 시도되는 호스트에서의 연결을 허용하도록
                  설정되지 않은 서버에 연결하려는 클라이언트에게
                  반환됩니다.

464     ERR_PASSWDMISMATCH
                ":Password incorrect"

                - 비밀번호가 필요하고 제공되지 않았거나 잘못된
                  연결 등록 시도가 실패했음을 나타내기 위해
                  반환됩니다.

465     ERR_YOUREBANNEDCREEP
                ":You are banned from this server"

                - 당신을 명시적으로 거부하도록 설정된 서버에
                  연결하고 등록하려는 시도 후 반환됩니다.

467     ERR_KEYSET
                "<channel> :Channel key already set"
471     ERR_CHANNELISFULL
                "<channel> :Cannot join channel (+l)"
472     ERR_UNKNOWNMODE
                "<char> :is unknown mode char to me"
473     ERR_INVITEONLYCHAN
                "<channel> :Cannot join channel (+i)"
474     ERR_BANNEDFROMCHAN
                "<channel> :Cannot join channel (+b)"
475     ERR_BADCHANNELKEY
                "<channel> :Cannot join channel (+k)"

481     ERR_NOPRIVILEGES
                ":Permission Denied- You're not an IRC operator"

                - 운영자 권한이 필요한 작업을 수행하려는 시도가
                  실패했음을 나타내기 위해 반환해야 합니다.

482     ERR_CHANOPRIVSNEEDED
                "<channel> :You're not channel operator"

                - MODE 메시지와 같이 'chanop' 권한이 필요한 명령은
                  시도를 하는 클라이언트가 지정된 채널의 채널
                  운영자가 아닌 경우 이 오류를 반환해야 합니다.

483     ERR_CANTKILLSERVER
                ":You cant kill a server!"

                - 서버에 대한 KILL 명령 사용 시도는 거부되어야 하며
                  이 오류가 클라이언트에게 직접 반환되어야 합니다.

491     ERR_NOOPERHOST
                ":No O-lines for your host"

                - 클라이언트가 OPER 메시지를 보내고 서버가 클라이언트의
                  호스트를 운영자로 연결을 허용하도록 구성되지 않은
                  경우 이 오류가 반환되어야 합니다.

501     ERR_UMODEUNKNOWNFLAG
                ":Unknown MODE flag"

                - 닉네임 매개변수와 함께 MODE 메시지가 전송되었고
                  전송된 모드 플래그가 인식되지 않았음을 나타내기
                  위해 서버가 반환합니다.

502     ERR_USERSDONTMATCH
                ":Cant change mode for other users"

                - 자신 이외의 사용자에 대한 사용자 모드를 보거나
                  변경하려는 모든 사용자에게 보내는 오류입니다.
```

### 6.2 명령 응답

```
300     RPL_NONE
                더미 응답 번호. 사용되지 않음.

302     RPL_USERHOST
                ":[<reply>{<space><reply>}]"

                - USERHOST가 쿼리 목록에 대한 응답을 나열하는 데
                  사용하는 응답 형식. 응답 문자열은 다음과 같이
                  구성됩니다:

                  <reply> ::= <nick>['*'] '=' <'+'|'-'><hostname>

                  '*'는 클라이언트가 운영자로 등록되었는지 여부를
                  나타냅니다. '-' 또는 '+' 문자는 클라이언트가
                  AWAY 메시지를 설정했는지 여부를 나타냅니다.

303     RPL_ISON
                ":[<nick> {<space><nick>}]"

                - ISON이 쿼리 목록에 대한 응답을 나열하는 데
                  사용하는 응답 형식.

301     RPL_AWAY
                "<nick> :<away message>"
305     RPL_UNAWAY
                ":You are no longer marked as being away"
306     RPL_NOWAWAY
                ":You have been marked as being away"

                - 이러한 응답들은 AWAY 명령과 함께 사용됩니다
                  (허용된 경우). RPL_AWAY는 자리 비움 상태인
                  클라이언트에게 PRIVMSG를 보내는 모든 클라이언트에게
                  전송됩니다. RPL_AWAY는 클라이언트가 연결된
                  서버에서만 전송됩니다. RPL_UNAWAY와 RPL_NOWAWAY
                  응답은 클라이언트가 AWAY 메시지를 제거하고
                  설정할 때 전송됩니다.

311     RPL_WHOISUSER
                "<nick> <user> <host> * :<real name>"
312     RPL_WHOISSERVER
                "<nick> <server> :<server info>"
313     RPL_WHOISOPERATOR
                "<nick> :is an IRC operator"
317     RPL_WHOISIDLE
                "<nick> <integer> :seconds idle"
318     RPL_ENDOFWHOIS
                "<nick> :End of /WHOIS list"
319     RPL_WHOISCHANNELS
                "<nick> :{[@|+]<channel><space>}"

                - 311 - 313, 317 - 319 응답은 모두 WHOIS 메시지에
                  대한 응답으로 생성됩니다. 충분한 매개변수가 있다면,
                  응답하는 서버는 위의 수치들로 응답을 구성하거나
                  (쿼리 닉네임이 발견된 경우) 오류 응답을 반환해야
                  합니다. RPL_WHOISUSER의 '*'는 와일드카드가 아닌
                  문자 그대로입니다. 각 응답 세트에 대해,
                  RPL_WHOISCHANNELS만 여러 번 나타날 수 있습니다
                  (긴 채널 이름 목록의 경우). 채널 이름 옆의 '@'와
                  '+' 문자는 클라이언트가 채널 운영자인지 또는
                  중재된 채널에서 발언 권한이 부여되었는지를
                  나타냅니다. RPL_ENDOFWHOIS 응답은 WHOIS 메시지
                  처리의 끝을 표시하는 데 사용됩니다.

314     RPL_WHOWASUSER
                "<nick> <user> <host> * :<real name>"
369     RPL_ENDOFWHOWAS
                "<nick> :End of WHOWAS"

                - WHOWAS 메시지에 응답할 때, 서버는 제시된 목록의
                  각 닉네임에 대해 RPL_WHOWASUSER, RPL_WHOISSERVER
                  또는 ERR_WASNOSUCHNICK을 사용해야 합니다.
                  모든 응답 배치의 끝에는 RPL_ENDOFWHOWAS가
                  있어야 합니다(단 하나의 응답만 있고 그것이
                  오류인 경우에도).

321     RPL_LISTSTART
                "Channel :Users  Name"
322     RPL_LIST
                "<channel> <# visible> :<topic>"
323     RPL_LISTEND
                ":End of /LIST"

                - RPL_LISTSTART, RPL_LIST, RPL_LISTEND 응답은
                  LIST 명령에 대한 서버의 응답의 시작, 실제 데이터가
                  있는 응답, 끝을 표시합니다. 반환할 채널이 없는
                  경우, 시작과 끝 응답만 보내야 합니다.

324     RPL_CHANNELMODEIS
                "<channel> <mode> <mode params>"

331     RPL_NOTOPIC
                "<channel> :No topic is set"
332     RPL_TOPIC
                "<channel> :<topic>"

                - 채널 토픽을 확인하기 위해 TOPIC 메시지를 보낼 때,
                  두 응답 중 하나가 전송됩니다. 토픽이 설정되어
                  있으면 RPL_TOPIC이 반환되고, 그렇지 않으면
                  RPL_NOTOPIC이 반환됩니다.
341     RPL_INVITING
               "<channel> <nick>"

               - 시도된 INVITE 메시지가 성공적이었고 최종
                 클라이언트에게 전달되고 있음을 나타내기 위해
                 서버가 반환합니다.

342     RPL_SUMMONING
               "<user> :Summoning user to IRC"

               - SUMMON 메시지에 응답하는 서버가 해당 사용자를
                 소환하고 있음을 나타내기 위해 반환합니다.

351     RPL_VERSION
               "<version>.<debuglevel> <server> :<comments>"

               - 서버가 자신의 버전 세부 정보를 보여주는 응답.
                 <version>은 사용 중인 소프트웨어의 버전입니다
                 (패치레벨 수정 포함). <debuglevel>은 서버가
                 "디버그 모드"로 실행 중인지를 나타내는 데
                 사용됩니다.

                 "comments" 필드는 버전에 대한 코멘트나 추가
                 버전 세부 정보를 포함할 수 있습니다.

352     RPL_WHOREPLY
               "<channel> <user> <host> <server> <nick> \
                <H|G>[*][@|+] :<hopcount> <real name>"
315     RPL_ENDOFWHO
               "<name> :End of /WHO list"

               - RPL_WHOREPLY와 RPL_ENDOFWHO 쌍은 WHO 메시지에
                 응답하는 데 사용됩니다. RPL_WHOREPLY는 WHO
                 쿼리와 적절히 일치하는 경우에만 전송됩니다.
                 WHO 메시지와 함께 매개변수 목록이 제공된 경우,
                 각 목록 항목을 처리한 후 <name>이 해당 항목인
                 RPL_ENDOFWHO가 전송되어야 합니다.

353     RPL_NAMREPLY
               "<channel> :[[@|+]<nick> [[@|+]<nick> [...]]]"
366     RPL_ENDOFNAMES
               "<channel> :End of /NAMES list"

               - NAMES 메시지에 응답하기 위해, RPL_NAMREPLY와
                 RPL_ENDOFNAMES로 구성된 응답 쌍이 서버에서
                 클라이언트로 다시 전송됩니다. 쿼리에서 채널을
                 찾을 수 없는 경우, RPL_ENDOFNAMES만 반환됩니다.
                 예외는 매개변수 없이 NAMES 메시지가 전송되고
                 모든 보이는 채널과 내용이 RPL_NAMEREPLY 메시지
                 시리즈로 다시 전송되며 RPL_ENDOFNAMES가 끝을
                 표시하는 경우입니다.     
200     RPL_TRACELINK
               "Link <version & debug level> <destination> \
                <next server>"
201     RPL_TRACECONNECTING
               "Try. <class> <server>"
202     RPL_TRACEHANDSHAKE
               "H.S. <class> <server>"
203     RPL_TRACEUNKNOWN
               "???? <class> [<client IP address in dot form>]"
204     RPL_TRACEOPERATOR
               "Oper <class> <nick>"
205     RPL_TRACEUSER
               "User <class> <nick>"
206     RPL_TRACESERVER
               "Serv <class> <int>S <int>C <server> \
                <nick!user|*!*>@<host|server>"
208     RPL_TRACENEWTYPE
               "<newtype> 0 <client name>"
261     RPL_TRACELOG
               "File <logfile> <debug level>"

               - RPL_TRACE* 응답들은 모두 TRACE 메시지에 대한
                 서버의 응답입니다. 얼마나 많은 응답이 반환되는지는
                 TRACE 메시지와 운영자가 보냈는지 여부에 따라
                 달라집니다. 반환되는 순서는 미리 정해져 있지
                 않습니다. RPL_TRACEUNKNOWN, RPL_TRACECONNECTING,
                 RPL_TRACEHANDSHAKE는 아직 완전히 설정되지 않은
                 연결에 사용됩니다. RPL_TRACELINK는 TRACE 메시지를
                 처리하고 다른 서버로 전달해야 하는 서버에 의해
                 전송됩니다. TRACE 명령을 통해 IRC 네트워크를
                 횡단하는 RPL_TRACELINK 목록은 해당 경로를 따라
                 서버의 실제 연결성을 반영해야 합니다.
                 RPL_TRACENEWTYPE은 다른 카테고리에 맞지 않지만
                 표시되는 모든 연결에 사용됩니다.

211     RPL_STATSLINKINFO
               "<linkname> <sendq> <sent messages> \
                <sent bytes> <received messages> \
                <received bytes> <time open>"
212     RPL_STATSCOMMANDS
               "<command> <count>"
               213     RPL_STATSCLINE
               "C <host> * <name> <port> <class>"
214     RPL_STATSNLINE
               "N <host> * <name> <port> <class>"
215     RPL_STATSILINE
               "I <host> * <host> <port> <class>"
216     RPL_STATSKLINE
               "K <host> * <username> <port> <class>"
218     RPL_STATSYLINE
               "Y <class> <ping frequency> <connect \
                frequency> <max sendq>"
219     RPL_ENDOFSTATS
               "<stats letter> :End of /STATS report"
241     RPL_STATSLLINE
               "L <hostmask> * <servername> <maxdepth>"
242     RPL_STATSUPTIME
               ":Server Up %d days %d:%02d:%02d"
243     RPL_STATSOLINE
               "O <hostmask> * <name>"
244     RPL_STATSHLINE
               "H <hostmask> * <servername>"

221     RPL_UMODEIS
               "<user mode string>"

               - 클라이언트 자신의 모드에 대한 쿼리에 응답할 때
                 RPL_UMODEIS가 다시 보내집니다.

251     RPL_LUSERCLIENT
               ":There are <integer> users and <integer> \
                invisible on <integer> servers"
252     RPL_LUSEROP
               "<integer> :operator(s) online"
253     RPL_LUSERUNKNOWN
               "<integer> :unknown connection(s)"
254     RPL_LUSERCHANNELS
               "<integer> :channels formed"
255     RPL_LUSERME
               ":I have <integer> clients and <integer> \
                servers"

               - LUSERS 메시지를 처리할 때 서버는 RPL_LUSERCLIENT,
                 RPL_LUSEROP, RPL_USERUNKNOWN, RPL_LUSERCHANNELS,
                 RPL_LUSERME로 구성된 응답 세트를 보냅니다. 응답할 때,
                 서버는 반드시 RPL_LUSERCLIENT와 RPL_LUSERME를
                 다시 보내야 합니다. 다른 응답들은 0이 아닌 개수가
                 발견된 경우에만 다시 보내집니다.

256     RPL_ADMINME
               "<server> :Administrative info"
257     RPL_ADMINLOC1
               ":<admin info>"
258     RPL_ADMINLOC2
               ":<admin info>"
259     RPL_ADMINEMAIL
               ":<admin info>"

               - ADMIN 메시지에 응답할 때, 서버는 RPL_ADMINME부터
                 RPL_ADMINEMAIL까지의 응답을 사용하고 각각에 대해
                 텍스트 메시지를 제공해야 합니다. RPL_ADMINLOC1에서는
                 서버가 있는 도시, 주, 국가에 대한 설명을, 
                 RPL_ADMINLOC2에서는 대학 및 부서에 대한 세부 정보를,
                 마지막으로 RPL_ADMINEMAIL에서는 서버의 관리 연락처
                 (여기서는 이메일 주소)를 제공해야 합니다.
```

### 6.3 예약된 숫자들

  이러한 숫자들은 위에서 설명되지 않았으며, 다음 카테고리 중 하나에 속합니다:

       1. 더 이상 사용되지 않음;

       2. 향후 계획된 사용을 위해 예약됨;

       3. 현재 사용 중이지만 현재 IRC 서버의 비통용적인 '기능'의 일부.

       209     RPL_TRACECLASS          217     RPL_STATSQLINE
       231     RPL_SERVICEINFO         232     RPL_ENDOFSERVICES
       233     RPL_SERVICE             234     RPL_SERVLIST
       235     RPL_SERVLISTEND
       316     RPL_WHOISCHANOP         361     RPL_KILLDONE
       362     RPL_CLOSING             363     RPL_CLOSEEND
       373     RPL_INFOSTART           384     RPL_MYPORTIS
       466     ERR_YOUWILLBEBANNED     476     ERR_BADCHANMASK
       492     ERR_NOSERVICEHOST

## 7. 클라이언트 및 서버 인증

  클라이언트와 서버는 모두 동일한 수준의 인증을 받습니다. 두 경우 모두 서버에 대한 모든 연결에 대해 IP 번호에서 호스트 이름으로의 룩업(및 이에 대한 역방향 확인)이 수행됩니다. 두 연결 모두 (연결에 대해 비밀번호가 설정된 경우) 비밀번호 검사를 받습니다. 이러한 검사는 모든 연결에서 가능하지만, 비밀번호 검사는 일반적으로 서버와의 연결에서만 사용됩니다.

  점점 더 흔해지는 추가 검사는 연결을 만든 사용자 이름에 대한 것입니다. 연결의 다른 쪽 끝의 사용자 이름을 찾는 것은 일반적으로 RFC 1413에 설명된 IDENT와 같은 인증 서버에 연결하는 것을 포함합니다.

  비밀번호 없이는 네트워크 연결의 다른 쪽 끝에 누가 있는지 신뢰할 수 있게 결정하기 어렵기 때문에, 다른 추가 조치와 함께 서버 간 연결에 비밀번호 사용을 강력히 권장합니다.

## 8. 현재 구현

  이 프로토콜의 유일한 현재 구현은 IRC 서버 버전 2.8입니다. 이전 버전들은 이 문서에서 설명하는 일부 또는 모든 명령을 구현할 수 있으며, 많은 숫자 응답 대신 NOTICE 메시지를 사용할 수 있습니다. 안타깝게도 이전 버전과의 호환성 요구 사항 때문에 이 문서에 설명된 일부 부분의 구현이 다릅니다. 주목할 만한 차이점은 다음과 같습니다:

       * 메시지의 어디에서든 LF 또는 CR이 메시지의 끝을 표시함을 인식
         (CR-LF 요구 대신);

  이 섹션의 나머지 부분은 서버를 구현하고자 하는 사람들에게 중요한 문제를 다루지만 일부는 클라이언트에도 직접 적용됩니다.

### 8.1 네트워크 프로토콜: TCP - 여기에서 가장 적합한 이유

IRC는 TCP 위에 구현되었습니다. TCP는 이러한 규모의 컨퍼런싱에 잘 맞는 신뢰할 수 있는 네트워크 프로토콜을 제공합니다. 멀티캐스트 IP의 사용은 대안이 될 수 있지만, 현재 널리 사용 가능하거나 지원되지 않습니다.

#### 8.1.1 Unix 소켓 지원

Unix 도메인 소켓이 listen/connect 작업을 허용하기 때문에, 현재 구현은 Unix 도메인 소켓에서 클라이언트 및 서버 연결을 수신 및 수락하도록 구성될 수 있습니다. 이러한 소켓들은 호스트 이름이 '/'로 시작하는 소켓으로 인식됩니다.

Unix 도메인 소켓의 연결에 대한 정보를 제공할 때, 서버는 실제 소켓 이름이 요청되는 것이 아니라면 실제 호스트 이름을 경로 이름 대신 대체해야 합니다.

### 8.2 명령 파싱

유용한 'non-buffered' 네트워크 I/O를 클라이언트와 서버에 제공하기 위해, 각 연결은 최근 읽기 및 파싱 결과를 보관하는 자체 개인 '입력 버퍼'를 가집니다. 1개의 전체 메시지를 보관할 수 있도록 512바이트 버퍼 크기가 사용됩니다. 하지만 이는 일반적으로 여러 명령을 보관할 수 있습니다. 개인 버퍼는 모든 읽기 작업 후에 유효한 메시지에 대해 파싱됩니다. 하나의 클라이언트로부터 버퍼에 여러 메시지가 있는 경우, 클라이언트가 '제거'될 수 있음을 고려하여 주의해야 합니다.

### 8.3 메시지 전달

네트워크 링크가 포화 상태이거나 데이터를 보내려는 호스트가 데이터를 보낼 수 없는 상황을 흔히 발견할 수 있습니다. Unix는 일반적으로 TCP 창 및 내부 버퍼를 통해 이를 처리하지만, 서버는 종종 대량의 데이터를 보내야 합니다(특히 새로운 서버-서버 링크가 형성될 때). 커널에서 제공하는 작은 버퍼는 발신 대기열에 충분하지 않습니다. 이 문제를 완화하기 위해 "send queue"가 데이터 전송을 위한 FIFO 대기열로 사용됩니다. 대형 IRC 네트워크에서 새 서버가 연결될 때 느린 네트워크 연결로 인해 "send queue"는 약 200KB까지 증가할 수 있습니다.

연결을 폴링할 때, 서버는 먼저 들어오는 모든 데이터를 읽고 파싱하고 보낼 데이터를 대기열에 넣습니다. 모든 사용 가능한 입력이 처리되면 대기열에 있는 데이터가 전송됩니다. 이는 write() 시스템 호출 횟수를 줄이고 TCP가 더 큰 패킷을 만들도록 돕습니다.


### 8.4 연결 '활성성'

연결이 주어진 시간 내에 응답하지 않을 때 서버는 해당 연결에 ping을 보내야 합니다.

연결이 정해진 시간 내에 응답하지 않으면, 적절한 절차를 사용하여 연결이 닫힙니다. 또한 연결의 sendq가 허용된 최대 크기를 초과하면 연결이 삭제됩니다. 이는 서버 프로세스가 느린 연결로 인해 차단되는 것보다 느린 연결을 닫는 것이 더 좋기 때문입니다.

### 8.5 서버-클라이언트 연결 설정

IRC 서버에 연결할 때, 클라이언트에게 MOTD(존재하는 경우)와 현재 사용자/서버 수(LUSER 명령에 따라)가 전송됩니다. 서버는 또한 자신의 이름과 버전, 그리고 적절하다고 판단되는 기타 소개 메시지를 명확하게 알려주는 메시지를 클라이언트에게 보내야 합니다.

이를 처리한 후, 서버는 자체적으로 제공된 새 사용자의 닉네임과 기타 정보, 그리고 서버가 발견할 수 있는 정보(DNS/인증 서버에서)를 보내야 합니다. 서버는 먼저 NICK을 보내고 그 다음 USER를 보내야 합니다.

### 8.6 서버-서버 연결 설정

서버-서버 연결 설정 프로세스는 많은 문제가 발생할 수 있는 영역이 있기 때문에 위험할 수 있습니다 - 가장 작은 것은 경합 조건입니다.

서버가 유효한 것으로 인식된 PASS/SERVER 쌍이 있는 연결을 받은 후, 해당 연결에 대한 자체 PASS/SERVER 정보와 알고 있는 다른 모든 상태 정보를 아래 설명된 대로 회신해야 합니다.

개시 서버가 PASS/SERVER 쌍을 받으면, 연결을 해당 서버로 수락하기 전에 응답하는 서버가 적절하게 인증되었는지 확인합니다.

#### 8.6.1 연결 시 서버 간 상태 정보 교환

상태 정보를 서버 간에 교환하는 순서는 필수적입니다. 필요한 순서는 다음과 같습니다:

- 알려진 다른 모든 서버들;
- 알려진 모든 사용자 정보;
- 알려진 모든 채널 정보.

서버에 대한 정보는 추가 SERVER 메시지를 통해 전송되고, 사용자 정보는 NICK/USER/MODE/JOIN 메시지로, 채널은 MODE 메시지로 전송됩니다.

참고: 채널 토픽은 여기서 교환되지 *않습니다*. TOPIC 명령이 이전 토픽 정보를 덮어쓰기 때문에, 최대한 연결의 양쪽이 토픽을 교환할 수 있습니다.

서버 상태 정보를 먼저 전달함으로써, 이미 존재하는 서버와의 충돌이 닉네임 충돌보다 먼저 발생할 수 있습니다. IRC 네트워크가 비순환 그래프로만 존재할 수 있기 때문에, 네트워크가 다른 위치에 이미 다시 연결되었을 가능성이 있으며, 충돌이 발생하는 위치는 네트워크가 분할되어야 하는 곳를 나타냅니다.

### 8.7 서버-클라이언트 연결 종료

클라이언트 연결이 닫힐 때, 클라이언트가 연결된 서버에 의해 클라이언트를 대신하여 QUIT 메시지가 생성됩니다. 다른 메시지는 생성되거나 사용되지 않아야 합니다.

### 8.8 서버-서버 연결 종료

서버-서버 연결이 원격으로 생성된 SQUIT나 '자연스러운' 원인에 의해 닫히는 경우, 연결 종료를 감지한 서버는 연결된 IRC 네트워크의 나머지 부분에 대한 정보를 업데이트해야 합니다. 서버는 해당 연결 뒤의 모든 서버에 대한 SQUIT 목록(각 서버당 하나)과 해당 연결 뒤의 모든 클라이언트에 대한 QUIT 목록(역시 각 클라이언트당 하나)을 보내야 합니다.

### 8.9 닉네임 변경 추적

모든 IRC 서버는 최근 닉네임 변경 이력을 유지해야 합니다. 이는 닉네임을 조작하는 명령에서 발생할 수 있는 닉네임 변경 경합 조건을 추적할 수 있도록 하기 위해 필요합니다. 닉네임 변경을 추적해야 하는 명령은 다음과 같습니다:

- KILL (킬되는 닉네임)
- MODE (+/- o,v)
- KICK (킥되는 닉네임)

다른 명령들은 닉네임 변경을 확인하지 않아야 합니다.

위의 경우, 서버는 먼저 닉네임의 존재 여부를 확인한 다음 해당 닉네임이 현재 누구에게 속해 있는지 확인하기 위해 해당 이력을 확인해야 합니다. 이는 경합 조건의 가능성을 줄이지만, 서버가 잘못된 클라이언트에 영향을 미칠 수 있는 경합 조건은 여전히 발생할 수 있습니다. 위의 명령에 대한 변경 추적을 수행할 때는 시간 범위를 제공하고 너무 오래된 항목은 무시하는 것이 좋습니다.

합리적인 이력을 위해, 서버는 알고 있는 모든 클라이언트의 이전 닉네임을 유지할 수 있어야 합니다(만약 그들 모두가 변경을 결정한 경우). 이 크기는 메모리 등의 다른 요인에 의해 제한됩니다.

### 8.10 클라이언트 플러드 제어

상호 연결된 대규모 IRC 서버 네트워크에서는 네트워크에 연결된 단일 클라이언트가 연속적인 메시지 스트림을 제공하여 네트워크를 플러딩하고 다른 사용자에게 제공되는 서비스 수준을 저하시킬 수 있습니다. 모든 '피해자'가 자체 보호를 제공하도록 요구하는 대신, 플러드 보호가 서버에 작성되었으며 서비스를 제외한 모든 클라이언트에 적용됩니다. 현재 알고리즘은 다음과 같습니다:

- 클라이언트의 '메시지 타이머'가 현재 시간보다 작은지 확인 (같은 경우 동일하게 설정);
- 클라이언트로부터 존재하는 데이터 읽기;
- 타이머가 현재 시간보다 10초 앞서 있는 동안, 존재하는 메시지를 파싱하고 각 메시지에 대해 클라이언트에게 2초의 페널티를 부과;

본질적으로 이는 클라이언트가 불리하게 영향을 받지 않고 2초마다 1개의 메시지를 보낼 수 있음을 의미합니다.

### 8.11 논블로킹 룩업

실시간 환경에서는 서버 프로세스가 가능한 한 대기 시간을 줄여 모든 클라이언트가 공정하게 서비스를 받을 수 있도록 하는 것이 중요합니다. 당연히 이는 모든 네트워크 읽기/쓰기 작업에 논블로킹 IO가 필요합니다. 일반 서버 연결의 경우 이는 어렵지 않았지만, 서버의 블로킹을 유발할 수 있는 다른 지원 작업들이 있습니다(디스크 읽기 등). 가능한 경우, 이러한 활동은 짧은 시간 초과와 함께 수행되어야 합니다.

#### 8.11.1 호스트 이름 (DNS) 룩업

Berkeley 및 기타의 표준 리졸버 라이브러리 사용은 일부 경우 응답 시간 초과로 인해 큰 지연을 의미했습니다. 이를 방지하기 위해, 논블로킹 IO 작업을 위해 설정된 별도의 DNS 루틴이 작성되었으며, 주 서버 IO 루프 내에서 폴링됩니다.

#### 8.11.2 사용자 이름 (Ident) 룩업

많은 ident 라이브러리가 있지만, 이들은 동기식 방식으로 작동하여 빈번한 지연을 야기했습니다. 다시 한번 해결책은 서버의 나머지 부분과 협력하고 논블로킹 IO를 사용하는 루틴 세트를 작성하는 것이었습니다.

### 8.12 구성 파일

서버를 설정하고 실행하는 유연한 방법을 제공하기 위해, 다음 내용에 대한 지침을 포함하는 구성 파일을 사용하는 것이 권장됩니다:

- 클라이언트 연결을 허용할 호스트;
- 서버로 연결할 수 있는 호스트;
- 연결할 호스트 (능동 및 수동 모두);
- 서버가 있는 위치에 대한 정보 (대학, 도시/주, 회사 등);
- 서버 책임자와 연락할 수 있는 이메일 주소;
- 제한된 운영자 명령에 대한 액세스 권한을 부여받으려는 클라이언트의 호스트 이름 및 비밀번호.

호스트 이름을 지정할 때, 도메인 이름과 'dot' 표기법(127.0.0.1) 모두 허용되어야 합니다. 모든 발신 및 수신 연결에 사용/허용될 비밀번호를 지정할 수 있어야 합니다 (단, 발신 연결은 다른 서버로의 연결뿐입니다).

위 목록은 다른 서버와 연결을 희망하는 모든 서버에 대한 최소 요구 사항입니다. 유용할 수 있는 다른 항목들은 다음과 같습니다:

- 다른 서버가 소개할 수 있는 서버 지정;
- 서버 분기가 될 수 있는 깊이;
- 클라이언트가 연결할 수 있는 시간.

#### 8.12.1 클라이언트 연결 허용

서버는 시작 시 읽히고 클라이언트가 연결할 수 있는 호스트를 결정하는 데 사용되는 일종의 '접근 제어 목록'(구성 파일 또는 기타 위치)을 사용해야 합니다.

호스트 접근 제어에 필요한 유연성을 제공하기 위해 '거부'와 '허용' 모두 구현되어야 합니다.

#### 8.12.2 운영자

파괴적인 사람에게 운영자 권한을 부여하면 일반적으로 IRC 네트워크의 전반적인 안녕에 심각한 결과를 초래할 수 있습니다. 따라서 이러한 권한 획득은 매우 쉽지 않아야 합니다. 현재 설정은 두 개의 '비밀번호'가 필요하지만, 그 중 하나는 일반적으로 쉽게 추측할 수 있습니다. oper 비밀번호를 하드 코딩하는 대신 구성 파일에 저장하는 것이 바람직하며, 쉬운 도용을 방지하기 위해 암호화된 형식(Unix의 crypt(3) 사용)으로 저장해야 합니다.

#### 8.12.3 서버 연결 허용

서버 상호 연결은 사소한 문제가 아닙니다: 잘못된 연결은 IRC의 유용성에 큰 영향을 미칠 수 있습니다. 따라서 각 서버는 연결할 수 있는 서버 목록과 자신에게 연결할 수 있는 서버 목록을 가져야 합니다. 어떤 경우에도 서버는 임의의 호스트가 서버로 연결하는 것을 허용해서는 안 됩니다. 연결할 수 있고 없는 서버 외에도, 구성 파일은 해당 링크의 비밀번호 및 기타 특성도 저장해야 합니다.

#### 8.12.4 관리 관련 사항

ADMIN 명령(섹션 4.3.7 참조)에 대한 정확하고 유효한 응답을 제공하기 위해, 서버는 구성에서 관련 세부 정보를 찾아야 합니다.

### 8.13 채널 멤버십

현재 서버는 등록된 로컬 사용자가 최대 10개의 다른 채널에 참여할 수 있도록 허용합니다. 서버가 다른 모든 서버와 합리적으로 일관성을 유지할 수 있도록 비로컬 사용자에게는 채널 멤버십에 대한 제한이 없습니다.

## 9. 현재 문제점

이 프로토콜에는 향후 재작성 중에 해결되기를 희망하는 여러 가지 인정된 문제점들이 있습니다. 현재 이러한 문제에 대한 작동 가능한 솔루션을 찾기 위한 작업이 진행 중입니다.

### 9.1 확장성

이 프로토콜이 대규모 영역에서 충분히 잘 확장되지 않는다는 점은 널리 인식되고 있습니다. 주요 문제는 모든 서버가 다른 모든 서버와 사용자에 대해 알아야 하고, 그에 대한 정보가 변경되는 즉시 업데이트되어야 한다는 요구 사항에서 비롯됩니다. 또한 어떤 두 지점 사이의 경로 길이를 최소로 유지하고 스패닝 트리를 가능한 한 강하게 분기시키기 위해 서버 수를 낮게 유지하는 것이 바람직합니다.

### 9.2 레이블

현재 IRC 프로토콜에는 3가지 유형의 레이블이 있습니다: 닉네임, 채널 이름, 서버 이름. 이 세 가지 유형은 각각 고유한 도메인을 가지고 있으며 해당 도메인 내에서 중복이 허용되지 않습니다. 현재는 사용자가 이 세 가지 중 어느 레이블이든 선택할 수 있어 충돌이 발생할 수 있습니다. 채널과 닉의 고유한 이름이 충돌하지 않도록 계획하고, 순환 트리를 허용하는 솔루션을 찾는 것이 바람직하다는 점이 널리 인식되고 있습니다.

#### 9.2.1 닉네임

IRC에서 닉네임의 개념은 채널 외부에서 서로 대화할 때 사용자에게 매우 편리하지만, 닉네임 공간은 유한하며, 본질적으로 여러 사람이 같은 닉을 사용하기를 원합니다. 이 프로토콜을 사용하여 두 사람이 닉네임을 선택하면, 둘 중 하나는 성공하지 못하거나 둘 다 KILL(4.6.1)에 의해 제거됩니다.

#### 9.2.2 채널

현재 채널 레이아웃은 모든 서버가 모든 채널, 그 구성원 및 속성을 알아야 합니다. 확장성이 좋지 않을 뿐만 아니라 개인 정보 보호 문제도 있습니다. 채널 충돌은 닉네임 충돌을 해결하는 데 사용되는 배타적인 방식이 아니라 포괄적인 이벤트로 처리됩니다.

#### 9.2.3 서버

사용자 및 채널 수에 비해 서버 수는 일반적으로 적지만, 현재 전역적으로 알려져야 하며 각각 개별적으로 또는 마스크 뒤에 숨겨져 있어야 합니다.

### 9.3 알고리즘

서버 코드의 일부 부분에서는 N^2 알고리즘(예: 클라이언트 집합의 채널 목록 확인)을 피할 수 없었습니다.

현재 서버 버전에서는 데이터베이스 일관성 검사가 없으며, 각 서버는 인접 서버가 올바르다고 가정합니다. 이는 연결하는 서버가 버그가 있거나 기존 네트워크에 모순을 도입하려고 시도할 경우 큰 문제를 야기할 수 있습니다.

현재, 고유한 내부 및 전역 레이블의 부재로 인해 많은 경합 조건이 존재합니다. 이러한 경합 조건은 일반적으로 메시지가 IRC 네트워크를 통과하고 영향을 미치는 데 시간이 걸리는 문제에서 발생합니다. 고유 레이블로 변경하더라도 채널 관련 명령이 방해되는 문제가 있습니다.

## 10. 현재 지원 및 가용성

IRC 관련 토론을 위한 메일링 리스트:
- 향후 프로토콜: ircd-three-request@eff.org
- 일반 토론: operlist-request@eff.org

소프트웨어 구현:
- cs.bu.edu:/irc
- nic.funet.fi:/pub/irc
- coombs.anu.edu.au:/pub/irc

뉴스그룹: alt.irc

## 보안 고려 사항

보안 문제는 섹션 4.1, 4.1.1, 4.1.3, 5.5, 및 7에서 논의됩니다.

## 12. 저자 주소

Jarkko Oikarinen
Tuirantie 17 as 9
90500 OULU
FINLAND

이메일: jto@tolsun.oulu.fi

Darren Reed
4 Pateman Street
Watsonia, Victoria 3087
호주

이메일: avalon@coombs.anu.edu.au